
GccBoardProject1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001ae6  00040000  00040000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000009a  00802000  00041ae6  00001b7a  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000008d7  0080209c  0080209c  00001c14  2**2
                  ALLOC
  3 .noinit       00000002  00802973  00802973  00001c14  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  00001c14  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 000003b8  00000000  00000000  00001c48  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000065f7  00000000  00000000  00002000  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001933  00000000  00000000  000085f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005208  00000000  00000000  00009f2a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000008ec  00000000  00000000  0000f134  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0002dfbe  00000000  00000000  0000fa20  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000022bc  00000000  00000000  0003d9de  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000310  00000000  00000000  0003fca0  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000aab0  00000000  00000000  0003ffb0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00040000 <__vectors>:
   40000:	fd c0       	rjmp	.+506    	; 0x401fc <__ctors_end>
   40002:	00 00       	nop
   40004:	1c c1       	rjmp	.+568    	; 0x4023e <__bad_interrupt>
   40006:	00 00       	nop
   40008:	1a c1       	rjmp	.+564    	; 0x4023e <__bad_interrupt>
   4000a:	00 00       	nop
   4000c:	18 c1       	rjmp	.+560    	; 0x4023e <__bad_interrupt>
   4000e:	00 00       	nop
   40010:	16 c1       	rjmp	.+556    	; 0x4023e <__bad_interrupt>
   40012:	00 00       	nop
   40014:	14 c1       	rjmp	.+552    	; 0x4023e <__bad_interrupt>
   40016:	00 00       	nop
   40018:	12 c1       	rjmp	.+548    	; 0x4023e <__bad_interrupt>
   4001a:	00 00       	nop
   4001c:	10 c1       	rjmp	.+544    	; 0x4023e <__bad_interrupt>
   4001e:	00 00       	nop
   40020:	0e c1       	rjmp	.+540    	; 0x4023e <__bad_interrupt>
   40022:	00 00       	nop
   40024:	0c c1       	rjmp	.+536    	; 0x4023e <__bad_interrupt>
   40026:	00 00       	nop
   40028:	0a c1       	rjmp	.+532    	; 0x4023e <__bad_interrupt>
   4002a:	00 00       	nop
   4002c:	08 c1       	rjmp	.+528    	; 0x4023e <__bad_interrupt>
   4002e:	00 00       	nop
   40030:	06 c1       	rjmp	.+524    	; 0x4023e <__bad_interrupt>
   40032:	00 00       	nop
   40034:	04 c1       	rjmp	.+520    	; 0x4023e <__bad_interrupt>
   40036:	00 00       	nop
   40038:	02 c1       	rjmp	.+516    	; 0x4023e <__bad_interrupt>
   4003a:	00 00       	nop
   4003c:	00 c1       	rjmp	.+512    	; 0x4023e <__bad_interrupt>
   4003e:	00 00       	nop
   40040:	fe c0       	rjmp	.+508    	; 0x4023e <__bad_interrupt>
   40042:	00 00       	nop
   40044:	fc c0       	rjmp	.+504    	; 0x4023e <__bad_interrupt>
   40046:	00 00       	nop
   40048:	fa c0       	rjmp	.+500    	; 0x4023e <__bad_interrupt>
   4004a:	00 00       	nop
   4004c:	f8 c0       	rjmp	.+496    	; 0x4023e <__bad_interrupt>
   4004e:	00 00       	nop
   40050:	f6 c0       	rjmp	.+492    	; 0x4023e <__bad_interrupt>
   40052:	00 00       	nop
   40054:	f4 c0       	rjmp	.+488    	; 0x4023e <__bad_interrupt>
   40056:	00 00       	nop
   40058:	f2 c0       	rjmp	.+484    	; 0x4023e <__bad_interrupt>
   4005a:	00 00       	nop
   4005c:	f0 c0       	rjmp	.+480    	; 0x4023e <__bad_interrupt>
   4005e:	00 00       	nop
   40060:	ee c0       	rjmp	.+476    	; 0x4023e <__bad_interrupt>
   40062:	00 00       	nop
   40064:	ec c0       	rjmp	.+472    	; 0x4023e <__bad_interrupt>
   40066:	00 00       	nop
   40068:	ea c0       	rjmp	.+468    	; 0x4023e <__bad_interrupt>
   4006a:	00 00       	nop
   4006c:	e8 c0       	rjmp	.+464    	; 0x4023e <__bad_interrupt>
   4006e:	00 00       	nop
   40070:	e6 c0       	rjmp	.+460    	; 0x4023e <__bad_interrupt>
   40072:	00 00       	nop
   40074:	e4 c0       	rjmp	.+456    	; 0x4023e <__bad_interrupt>
   40076:	00 00       	nop
   40078:	e2 c0       	rjmp	.+452    	; 0x4023e <__bad_interrupt>
   4007a:	00 00       	nop
   4007c:	e0 c0       	rjmp	.+448    	; 0x4023e <__bad_interrupt>
   4007e:	00 00       	nop
   40080:	de c0       	rjmp	.+444    	; 0x4023e <__bad_interrupt>
   40082:	00 00       	nop
   40084:	dc c0       	rjmp	.+440    	; 0x4023e <__bad_interrupt>
   40086:	00 00       	nop
   40088:	da c0       	rjmp	.+436    	; 0x4023e <__bad_interrupt>
   4008a:	00 00       	nop
   4008c:	d8 c0       	rjmp	.+432    	; 0x4023e <__bad_interrupt>
   4008e:	00 00       	nop
   40090:	d6 c0       	rjmp	.+428    	; 0x4023e <__bad_interrupt>
   40092:	00 00       	nop
   40094:	d4 c0       	rjmp	.+424    	; 0x4023e <__bad_interrupt>
   40096:	00 00       	nop
   40098:	d2 c0       	rjmp	.+420    	; 0x4023e <__bad_interrupt>
   4009a:	00 00       	nop
   4009c:	d0 c0       	rjmp	.+416    	; 0x4023e <__bad_interrupt>
   4009e:	00 00       	nop
   400a0:	ce c0       	rjmp	.+412    	; 0x4023e <__bad_interrupt>
   400a2:	00 00       	nop
   400a4:	cc c0       	rjmp	.+408    	; 0x4023e <__bad_interrupt>
   400a6:	00 00       	nop
   400a8:	ca c0       	rjmp	.+404    	; 0x4023e <__bad_interrupt>
   400aa:	00 00       	nop
   400ac:	c8 c0       	rjmp	.+400    	; 0x4023e <__bad_interrupt>
   400ae:	00 00       	nop
   400b0:	c6 c0       	rjmp	.+396    	; 0x4023e <__bad_interrupt>
   400b2:	00 00       	nop
   400b4:	c4 c0       	rjmp	.+392    	; 0x4023e <__bad_interrupt>
   400b6:	00 00       	nop
   400b8:	c2 c0       	rjmp	.+388    	; 0x4023e <__bad_interrupt>
   400ba:	00 00       	nop
   400bc:	c0 c0       	rjmp	.+384    	; 0x4023e <__bad_interrupt>
   400be:	00 00       	nop
   400c0:	be c0       	rjmp	.+380    	; 0x4023e <__bad_interrupt>
   400c2:	00 00       	nop
   400c4:	bc c0       	rjmp	.+376    	; 0x4023e <__bad_interrupt>
   400c6:	00 00       	nop
   400c8:	ba c0       	rjmp	.+372    	; 0x4023e <__bad_interrupt>
   400ca:	00 00       	nop
   400cc:	b8 c0       	rjmp	.+368    	; 0x4023e <__bad_interrupt>
   400ce:	00 00       	nop
   400d0:	b6 c0       	rjmp	.+364    	; 0x4023e <__bad_interrupt>
   400d2:	00 00       	nop
   400d4:	b4 c0       	rjmp	.+360    	; 0x4023e <__bad_interrupt>
   400d6:	00 00       	nop
   400d8:	b2 c0       	rjmp	.+356    	; 0x4023e <__bad_interrupt>
   400da:	00 00       	nop
   400dc:	b0 c0       	rjmp	.+352    	; 0x4023e <__bad_interrupt>
   400de:	00 00       	nop
   400e0:	ae c0       	rjmp	.+348    	; 0x4023e <__bad_interrupt>
   400e2:	00 00       	nop
   400e4:	ac c0       	rjmp	.+344    	; 0x4023e <__bad_interrupt>
   400e6:	00 00       	nop
   400e8:	aa c0       	rjmp	.+340    	; 0x4023e <__bad_interrupt>
   400ea:	00 00       	nop
   400ec:	a8 c0       	rjmp	.+336    	; 0x4023e <__bad_interrupt>
   400ee:	00 00       	nop
   400f0:	a6 c0       	rjmp	.+332    	; 0x4023e <__bad_interrupt>
   400f2:	00 00       	nop
   400f4:	a4 c0       	rjmp	.+328    	; 0x4023e <__bad_interrupt>
   400f6:	00 00       	nop
   400f8:	a2 c0       	rjmp	.+324    	; 0x4023e <__bad_interrupt>
   400fa:	00 00       	nop
   400fc:	a0 c0       	rjmp	.+320    	; 0x4023e <__bad_interrupt>
   400fe:	00 00       	nop
   40100:	9e c0       	rjmp	.+316    	; 0x4023e <__bad_interrupt>
   40102:	00 00       	nop
   40104:	9c c0       	rjmp	.+312    	; 0x4023e <__bad_interrupt>
   40106:	00 00       	nop
   40108:	9a c0       	rjmp	.+308    	; 0x4023e <__bad_interrupt>
   4010a:	00 00       	nop
   4010c:	98 c0       	rjmp	.+304    	; 0x4023e <__bad_interrupt>
   4010e:	00 00       	nop
   40110:	96 c0       	rjmp	.+300    	; 0x4023e <__bad_interrupt>
   40112:	00 00       	nop
   40114:	94 c0       	rjmp	.+296    	; 0x4023e <__bad_interrupt>
   40116:	00 00       	nop
   40118:	92 c0       	rjmp	.+292    	; 0x4023e <__bad_interrupt>
   4011a:	00 00       	nop
   4011c:	90 c0       	rjmp	.+288    	; 0x4023e <__bad_interrupt>
   4011e:	00 00       	nop
   40120:	8e c0       	rjmp	.+284    	; 0x4023e <__bad_interrupt>
   40122:	00 00       	nop
   40124:	8c c0       	rjmp	.+280    	; 0x4023e <__bad_interrupt>
   40126:	00 00       	nop
   40128:	8a c0       	rjmp	.+276    	; 0x4023e <__bad_interrupt>
   4012a:	00 00       	nop
   4012c:	88 c0       	rjmp	.+272    	; 0x4023e <__bad_interrupt>
   4012e:	00 00       	nop
   40130:	86 c0       	rjmp	.+268    	; 0x4023e <__bad_interrupt>
   40132:	00 00       	nop
   40134:	84 c0       	rjmp	.+264    	; 0x4023e <__bad_interrupt>
   40136:	00 00       	nop
   40138:	82 c0       	rjmp	.+260    	; 0x4023e <__bad_interrupt>
   4013a:	00 00       	nop
   4013c:	80 c0       	rjmp	.+256    	; 0x4023e <__bad_interrupt>
   4013e:	00 00       	nop
   40140:	7e c0       	rjmp	.+252    	; 0x4023e <__bad_interrupt>
   40142:	00 00       	nop
   40144:	7c c0       	rjmp	.+248    	; 0x4023e <__bad_interrupt>
   40146:	00 00       	nop
   40148:	7a c0       	rjmp	.+244    	; 0x4023e <__bad_interrupt>
   4014a:	00 00       	nop
   4014c:	78 c0       	rjmp	.+240    	; 0x4023e <__bad_interrupt>
   4014e:	00 00       	nop
   40150:	76 c0       	rjmp	.+236    	; 0x4023e <__bad_interrupt>
   40152:	00 00       	nop
   40154:	74 c0       	rjmp	.+232    	; 0x4023e <__bad_interrupt>
   40156:	00 00       	nop
   40158:	72 c0       	rjmp	.+228    	; 0x4023e <__bad_interrupt>
   4015a:	00 00       	nop
   4015c:	70 c0       	rjmp	.+224    	; 0x4023e <__bad_interrupt>
   4015e:	00 00       	nop
   40160:	6e c0       	rjmp	.+220    	; 0x4023e <__bad_interrupt>
   40162:	00 00       	nop
   40164:	6c c0       	rjmp	.+216    	; 0x4023e <__bad_interrupt>
   40166:	00 00       	nop
   40168:	6a c0       	rjmp	.+212    	; 0x4023e <__bad_interrupt>
   4016a:	00 00       	nop
   4016c:	68 c0       	rjmp	.+208    	; 0x4023e <__bad_interrupt>
   4016e:	00 00       	nop
   40170:	66 c0       	rjmp	.+204    	; 0x4023e <__bad_interrupt>
   40172:	00 00       	nop
   40174:	64 c0       	rjmp	.+200    	; 0x4023e <__bad_interrupt>
   40176:	00 00       	nop
   40178:	62 c0       	rjmp	.+196    	; 0x4023e <__bad_interrupt>
   4017a:	00 00       	nop
   4017c:	60 c0       	rjmp	.+192    	; 0x4023e <__bad_interrupt>
   4017e:	00 00       	nop
   40180:	5e c0       	rjmp	.+188    	; 0x4023e <__bad_interrupt>
   40182:	00 00       	nop
   40184:	5c c0       	rjmp	.+184    	; 0x4023e <__bad_interrupt>
   40186:	00 00       	nop
   40188:	5a c0       	rjmp	.+180    	; 0x4023e <__bad_interrupt>
   4018a:	00 00       	nop
   4018c:	58 c0       	rjmp	.+176    	; 0x4023e <__bad_interrupt>
   4018e:	00 00       	nop
   40190:	56 c0       	rjmp	.+172    	; 0x4023e <__bad_interrupt>
   40192:	00 00       	nop
   40194:	54 c0       	rjmp	.+168    	; 0x4023e <__bad_interrupt>
   40196:	00 00       	nop
   40198:	52 c0       	rjmp	.+164    	; 0x4023e <__bad_interrupt>
   4019a:	00 00       	nop
   4019c:	50 c0       	rjmp	.+160    	; 0x4023e <__bad_interrupt>
   4019e:	00 00       	nop
   401a0:	4e c0       	rjmp	.+156    	; 0x4023e <__bad_interrupt>
   401a2:	00 00       	nop
   401a4:	4c c0       	rjmp	.+152    	; 0x4023e <__bad_interrupt>
   401a6:	00 00       	nop
   401a8:	4a c0       	rjmp	.+148    	; 0x4023e <__bad_interrupt>
   401aa:	00 00       	nop
   401ac:	48 c0       	rjmp	.+144    	; 0x4023e <__bad_interrupt>
   401ae:	00 00       	nop
   401b0:	46 c0       	rjmp	.+140    	; 0x4023e <__bad_interrupt>
   401b2:	00 00       	nop
   401b4:	44 c0       	rjmp	.+136    	; 0x4023e <__bad_interrupt>
   401b6:	00 00       	nop
   401b8:	42 c0       	rjmp	.+132    	; 0x4023e <__bad_interrupt>
   401ba:	00 00       	nop
   401bc:	40 c0       	rjmp	.+128    	; 0x4023e <__bad_interrupt>
   401be:	00 00       	nop
   401c0:	3e c0       	rjmp	.+124    	; 0x4023e <__bad_interrupt>
   401c2:	00 00       	nop
   401c4:	3c c0       	rjmp	.+120    	; 0x4023e <__bad_interrupt>
   401c6:	00 00       	nop
   401c8:	3a c0       	rjmp	.+116    	; 0x4023e <__bad_interrupt>
   401ca:	00 00       	nop
   401cc:	38 c0       	rjmp	.+112    	; 0x4023e <__bad_interrupt>
   401ce:	00 00       	nop
   401d0:	36 c0       	rjmp	.+108    	; 0x4023e <__bad_interrupt>
   401d2:	00 00       	nop
   401d4:	34 c0       	rjmp	.+104    	; 0x4023e <__bad_interrupt>
   401d6:	00 00       	nop
   401d8:	32 c0       	rjmp	.+100    	; 0x4023e <__bad_interrupt>
   401da:	00 00       	nop
   401dc:	30 c0       	rjmp	.+96     	; 0x4023e <__bad_interrupt>
   401de:	00 00       	nop
   401e0:	2e c0       	rjmp	.+92     	; 0x4023e <__bad_interrupt>
   401e2:	00 00       	nop
   401e4:	2c c0       	rjmp	.+88     	; 0x4023e <__bad_interrupt>
   401e6:	00 00       	nop
   401e8:	2a c0       	rjmp	.+84     	; 0x4023e <__bad_interrupt>
   401ea:	00 00       	nop
   401ec:	28 c0       	rjmp	.+80     	; 0x4023e <__bad_interrupt>
   401ee:	00 00       	nop
   401f0:	26 c0       	rjmp	.+76     	; 0x4023e <__bad_interrupt>
   401f2:	00 00       	nop
   401f4:	5f c7       	rjmp	.+3774   	; 0x410b4 <__vector_125>
   401f6:	00 00       	nop
   401f8:	1c 94 0c 09 	jmp	0x41218	; 0x41218 <__vector_126>

000401fc <__ctors_end>:
   401fc:	11 24       	eor	r1, r1
   401fe:	1f be       	out	0x3f, r1	; 63
   40200:	cf ef       	ldi	r28, 0xFF	; 255
   40202:	cd bf       	out	0x3d, r28	; 61
   40204:	df e5       	ldi	r29, 0x5F	; 95
   40206:	de bf       	out	0x3e, r29	; 62
   40208:	02 e0       	ldi	r16, 0x02	; 2
   4020a:	0c bf       	out	0x3c, r16	; 60

0004020c <__do_copy_data>:
   4020c:	10 e2       	ldi	r17, 0x20	; 32
   4020e:	a0 e0       	ldi	r26, 0x00	; 0
   40210:	b0 e2       	ldi	r27, 0x20	; 32
   40212:	e6 ee       	ldi	r30, 0xE6	; 230
   40214:	fa e1       	ldi	r31, 0x1A	; 26
   40216:	04 e0       	ldi	r16, 0x04	; 4
   40218:	0b bf       	out	0x3b, r16	; 59
   4021a:	02 c0       	rjmp	.+4      	; 0x40220 <__do_copy_data+0x14>
   4021c:	07 90       	elpm	r0, Z+
   4021e:	0d 92       	st	X+, r0
   40220:	aa 39       	cpi	r26, 0x9A	; 154
   40222:	b1 07       	cpc	r27, r17
   40224:	d9 f7       	brne	.-10     	; 0x4021c <__do_copy_data+0x10>

00040226 <__do_clear_bss>:
   40226:	29 e2       	ldi	r18, 0x29	; 41
   40228:	ac e9       	ldi	r26, 0x9C	; 156
   4022a:	b0 e2       	ldi	r27, 0x20	; 32
   4022c:	01 c0       	rjmp	.+2      	; 0x40230 <.do_clear_bss_start>

0004022e <.do_clear_bss_loop>:
   4022e:	1d 92       	st	X+, r1

00040230 <.do_clear_bss_start>:
   40230:	a3 37       	cpi	r26, 0x73	; 115
   40232:	b2 07       	cpc	r27, r18
   40234:	e1 f7       	brne	.-8      	; 0x4022e <.do_clear_bss_loop>
   40236:	1e 94 da 0c 	call	0x419b4	; 0x419b4 <main>
   4023a:	1c 94 71 0d 	jmp	0x41ae2	; 0x41ae2 <_exit>

0004023e <__bad_interrupt>:
   4023e:	e0 ce       	rjmp	.-576    	; 0x40000 <__vectors>

00040240 <nvm_common_spm>:
	/**
	 * For GCC:
	 * \param address uint32_t r22:r25
	 * \param nvm_cmd uint8_t  r20
	 */
	in r25, RAMPZ         ; Store RAMPZ. Highest address byte is ignored, so using that
   40240:	9b b7       	in	r25, 0x3b	; 59
	out RAMPZ, r24        ; Load R24 into RAMPZ
   40242:	8b bf       	out	0x3b, r24	; 59
	movw ZL, r22          ; Load R22:R23 into Z.
   40244:	fb 01       	movw	r30, r22
	lds r24, NVM_CMD      ; Store NVM command register (r24 is no longer needed)
   40246:	80 91 ca 01 	lds	r24, 0x01CA
	sts NVM_CMD, r20      ; Load prepared command into NVM Command register.
   4024a:	40 93 ca 01 	sts	0x01CA, r20
	ldi r23, CCP_SPM_gc   ; Prepare Protect SPM signature (r23 is no longer needed)
   4024e:	7d e9       	ldi	r23, 0x9D	; 157
	sts CCP, r23          ; Enable SPM operation (this disables interrupts for 4 cycles).
   40250:	70 93 34 00 	sts	0x0034, r23
	spm                   ; Self-program.
   40254:	e8 95       	spm
	sts NVM_CMD, r24      ; Restore NVM command register
   40256:	80 93 ca 01 	sts	0x01CA, r24
	out RAMPZ, r25        ; Restore RAMPZ register.
   4025a:	9b bf       	out	0x3b, r25	; 59
	spm                   ; Self-program.
	sts NVM_CMD, r18      ; Restore NVM command register
	out RAMPZ, r19        ; Restore RAMPZ register.
#endif

	ret
   4025c:	08 95       	ret

0004025e <nvm_flash_load_word_to_buffer>:
	 * For GCC:
	 * \param word_addr uint32_t r22:r25
	 * \param data      uint16_t r20:r21
	 */
wait_nvm:
	lds r18, NVM_STATUS
   4025e:	20 91 cf 01 	lds	r18, 0x01CF
	sbrc r18, NVM_NVMBUSY_bp
   40262:	27 fd       	sbrc	r18, 7
	rjmp wait_nvm
   40264:	fc cf       	rjmp	.-8      	; 0x4025e <nvm_flash_load_word_to_buffer>

	in r25, RAMPZ         ; Store RAMPZ. Highest address byte is ignored, so using that
   40266:	9b b7       	in	r25, 0x3b	; 59
	out RAMPZ, r24        ; Load R24 into RAMPZ
   40268:	8b bf       	out	0x3b, r24	; 59
	movw ZL, r22          ; Load R22:R23 into Z.
   4026a:	fb 01       	movw	r30, r22

	lds r24, NVM_CMD      ; Store NVM command register (r24 is no longer needed)
   4026c:	80 91 ca 01 	lds	r24, 0x01CA
	ldi r18, NVM_CMD_LOAD_FLASH_BUFFER_gc
   40270:	23 e2       	ldi	r18, 0x23	; 35
	sts NVM_CMD, r18      ; Load prepared command into NVM Command register.
   40272:	20 93 ca 01 	sts	0x01CA, r18

	movw r0, r20          ; Load R20:R21 into R0:R1
   40276:	0a 01       	movw	r0, r20
	spm                   ; Self-program.
   40278:	e8 95       	spm

	clr r1                ; Clear R1 for GCC _zero_reg_ to function properly.
   4027a:	11 24       	eor	r1, r1
	sts NVM_CMD, r24      ; Restore NVM command register
   4027c:	80 93 ca 01 	sts	0x01CA, r24
	out RAMPZ, r25        ; Restore RAMPZ register.
   40280:	9b bf       	out	0x3b, r25	; 59

	sts NVM_CMD, r18      ; Restore NVM command register
	out RAMPZ, r19        ; Restore RAMPZ register.
#endif

	ret
   40282:	08 95       	ret

00040284 <udi_dfu_atmel_disable>:
	return UDI_DFU_ENABLE_EXT();
}


void udi_dfu_atmel_disable(void)
{
   40284:	08 95       	ret

00040286 <udi_dfu_atmel_getsetting>:


uint8_t udi_dfu_atmel_getsetting(void)
{
	return 0;
}
   40286:	80 e0       	ldi	r24, 0x00	; 0
   40288:	08 95       	ret

0004028a <udi_dfu_atmel_reset_protocol>:


static void udi_dfu_atmel_reset_protocol(void)
{
	// Reset DFU status
	udi_dfu_atmel_status.bStatus = DFU_STATUS_OK;
   4028a:	10 92 ee 28 	sts	0x28EE, r1
	udi_dfu_atmel_status.bState = DFU_STATE_DFUIDLE;
   4028e:	82 e0       	ldi	r24, 0x02	; 2
   40290:	80 93 f2 28 	sts	0x28F2, r24
	// These fields are not used and always set to zero:
	// bwPollTimeout[3]
	// iString

	// Reset all callbacks
	udd_g_ctrlreq.over_under_run = NULL;
   40294:	10 92 71 29 	sts	0x2971, r1
   40298:	10 92 72 29 	sts	0x2972, r1
	udd_g_ctrlreq.callback = NULL;
   4029c:	10 92 6f 29 	sts	0x296F, r1
   402a0:	10 92 70 29 	sts	0x2970, r1
   402a4:	08 95       	ret

000402a6 <udi_dfu_atmel_mem_protected>:
	udi_dfu_atmel_mem_sel = *isp_memories.mem[mem_num];
}

static bool udi_dfu_atmel_mem_protected(void)
{
	udi_dfu_atmel_status.bStatus = DFU_STATUS_ERRWRITE;
   402a6:	83 e0       	ldi	r24, 0x03	; 3
   402a8:	80 93 ee 28 	sts	0x28EE, r24
	udi_dfu_atmel_status.bState = DFU_STATE_DFUIDLE;
   402ac:	82 e0       	ldi	r24, 0x02	; 2
   402ae:	80 93 f2 28 	sts	0x28F2, r24
	return false;
}
   402b2:	80 e0       	ldi	r24, 0x00	; 0
   402b4:	08 95       	ret

000402b6 <udi_dfu_atmel_mem_getaddr>:


static bool udi_dfu_atmel_mem_getaddr(uint8_t * arg)
{
   402b6:	fc 01       	movw	r30, r24
	isp_addr_t addr_end;

	// Get address for request argument
	udi_dfu_atmel_mem_add =
		(udi_dfu_atmel_mem_add&0xFFFF0000) + ((uint16_t)arg[0]<<8) + (arg[1]<<0);
   402b8:	20 81       	ld	r18, Z
   402ba:	30 e0       	ldi	r19, 0x00	; 0
   402bc:	32 2f       	mov	r19, r18
   402be:	22 27       	eor	r18, r18
static bool udi_dfu_atmel_mem_getaddr(uint8_t * arg)
{
	isp_addr_t addr_end;

	// Get address for request argument
	udi_dfu_atmel_mem_add =
   402c0:	81 81       	ldd	r24, Z+1	; 0x01
   402c2:	28 0f       	add	r18, r24
   402c4:	31 1d       	adc	r19, r1
   402c6:	20 93 a6 20 	sts	0x20A6, r18
   402ca:	30 93 a7 20 	sts	0x20A7, r19
		(udi_dfu_atmel_mem_add&0xFFFF0000) + ((uint16_t)arg[0]<<8) + (arg[1]<<0);
	addr_end =
		(udi_dfu_atmel_mem_add&0xFFFF0000) + ((uint16_t)arg[2]<<8) + (arg[3]<<0);
   402ce:	82 81       	ldd	r24, Z+2	; 0x02
   402d0:	90 e0       	ldi	r25, 0x00	; 0
   402d2:	98 2f       	mov	r25, r24
   402d4:	88 27       	eor	r24, r24
	isp_addr_t addr_end;

	// Get address for request argument
	udi_dfu_atmel_mem_add =
		(udi_dfu_atmel_mem_add&0xFFFF0000) + ((uint16_t)arg[0]<<8) + (arg[1]<<0);
	addr_end =
   402d6:	43 81       	ldd	r20, Z+3	; 0x03
   402d8:	fc 01       	movw	r30, r24
   402da:	e4 0f       	add	r30, r20
   402dc:	f1 1d       	adc	r31, r1
		(udi_dfu_atmel_mem_add&0xFFFF0000) + ((uint16_t)arg[2]<<8) + (arg[3]<<0);

	Assert(addr_end >= udi_dfu_atmel_mem_add);

	// Check address
	if (addr_end >= udi_dfu_atmel_mem_sel.size) {
   402de:	af 01       	movw	r20, r30
   402e0:	60 e0       	ldi	r22, 0x00	; 0
   402e2:	70 e0       	ldi	r23, 0x00	; 0
   402e4:	80 91 9c 20 	lds	r24, 0x209C
   402e8:	90 91 9d 20 	lds	r25, 0x209D
   402ec:	a0 91 9e 20 	lds	r26, 0x209E
   402f0:	b0 91 9f 20 	lds	r27, 0x209F
   402f4:	48 17       	cp	r20, r24
   402f6:	59 07       	cpc	r21, r25
   402f8:	6a 07       	cpc	r22, r26
   402fa:	7b 07       	cpc	r23, r27
   402fc:	40 f0       	brcs	.+16     	; 0x4030e <udi_dfu_atmel_mem_getaddr+0x58>
		udi_dfu_atmel_status.bStatus = DFU_STATUS_ERRADDRESS;
   402fe:	88 e0       	ldi	r24, 0x08	; 8
   40300:	80 93 ee 28 	sts	0x28EE, r24
		udi_dfu_atmel_status.bState = DFU_STATE_DFUERROR;
   40304:	8a e0       	ldi	r24, 0x0A	; 10
   40306:	80 93 f2 28 	sts	0x28F2, r24
		return false;
   4030a:	80 e0       	ldi	r24, 0x00	; 0
   4030c:	08 95       	ret
	}

	// Compute the number of data to transfer
	udi_dfu_atmel_mem_nb_data = addr_end - udi_dfu_atmel_mem_add + 1;
   4030e:	31 96       	adiw	r30, 0x01	; 1
   40310:	e2 1b       	sub	r30, r18
   40312:	f3 0b       	sbc	r31, r19
   40314:	e0 93 a4 20 	sts	0x20A4, r30
   40318:	f0 93 a5 20 	sts	0x20A5, r31
	return true;
   4031c:	81 e0       	ldi	r24, 0x01	; 1
}
   4031e:	08 95       	ret

00040320 <udi_dfu_atmel_mem_write>:

	// In order to be in accordance with the memory write entity (page size),
	// X non-significant bytes may be added before the first byte to program.
	// The X number is calculated to align the beginning of the firmware
	// with the memory write entity.
	padding_prefix = Get_align(udi_dfu_atmel_mem_add,
   40320:	80 91 a6 20 	lds	r24, 0x20A6
			USB_DEVICE_EP_CTRL_SIZE);

		// Program data in memory
		udi_dfu_atmel_mem_sel.fnct_write
				(udi_dfu_atmel_mem_add,
   40324:	40 91 a4 20 	lds	r20, 0x20A4
   40328:	50 91 a5 20 	lds	r21, 0x20A5

	// In order to be in accordance with the memory write entity (page size),
	// X non-significant bytes may be added before the first byte to program.
	// The X number is calculated to align the beginning of the firmware
	// with the memory write entity.
	padding_prefix = Get_align(udi_dfu_atmel_mem_add,
   4032c:	68 2f       	mov	r22, r24
   4032e:	6f 73       	andi	r22, 0x3F	; 63
			USB_DEVICE_EP_CTRL_SIZE);

		// Program data in memory
		udi_dfu_atmel_mem_sel.fnct_write
				(udi_dfu_atmel_mem_add,
   40330:	70 e0       	ldi	r23, 0x00	; 0
   40332:	62 55       	subi	r22, 0x52	; 82
   40334:	7f 4d       	sbci	r23, 0xDF	; 223
   40336:	e0 91 a2 20 	lds	r30, 0x20A2
   4033a:	f0 91 a3 20 	lds	r31, 0x20A3
   4033e:	90 91 a7 20 	lds	r25, 0x20A7
   40342:	19 95       	eicall
				udi_dfu_atmel_buf_trans + padding_prefix,
				udi_dfu_atmel_mem_nb_data);

	// Init callback called after buffer filled
	udd_g_ctrlreq.over_under_run = NULL;
   40344:	10 92 71 29 	sts	0x2971, r1
   40348:	10 92 72 29 	sts	0x2972, r1
	return true;
}
   4034c:	81 e0       	ldi	r24, 0x01	; 1
   4034e:	08 95       	ret

00040350 <udi_dfu_atmel_enable>:
//@}


bool udi_dfu_atmel_enable(void)
{
	udi_dfu_atmel_reset = false;
   40350:	10 92 aa 20 	sts	0x20AA, r1
	udi_dfu_atmel_reset_protocol();
   40354:	9a df       	rcall	.-204    	; 0x4028a <udi_dfu_atmel_reset_protocol>
	// Load chip information
	isp_init();
   40356:	1e 94 ec 09 	call	0x413d8	; 0x413d8 <isp_init>
	udi_dfu_atmel_security = isp_is_security();
   4035a:	1e 94 fb 09 	call	0x413f6	; 0x413f6 <isp_is_security>
   4035e:	80 93 a9 20 	sts	0x20A9, r24
	return UDI_DFU_ENABLE_EXT();
}
   40362:	81 e0       	ldi	r24, 0x01	; 1
   40364:	08 95       	ret

00040366 <udi_dfu_atmel_mem_read>:


static bool udi_dfu_atmel_mem_read(void)
{
	Assert(udi_dfu_atmel_mem_nb_data <= DFU_ATMEL_BUF_TRANS_SIZE);
	udi_dfu_atmel_mem_sel.fnct_read(udi_dfu_atmel_buf_trans,
   40366:	40 91 a4 20 	lds	r20, 0x20A4
   4036a:	50 91 a5 20 	lds	r21, 0x20A5
   4036e:	60 91 a6 20 	lds	r22, 0x20A6
   40372:	70 91 a7 20 	lds	r23, 0x20A7
   40376:	e0 91 a0 20 	lds	r30, 0x20A0
   4037a:	f0 91 a1 20 	lds	r31, 0x20A1
   4037e:	8e ea       	ldi	r24, 0xAE	; 174
   40380:	90 e2       	ldi	r25, 0x20	; 32
   40382:	19 95       	eicall
		udi_dfu_atmel_mem_add, udi_dfu_atmel_mem_nb_data);

	// Init buffer to transfer
	udd_set_setup_payload( udi_dfu_atmel_buf_trans, udi_dfu_atmel_mem_nb_data);
   40384:	60 91 a4 20 	lds	r22, 0x20A4
   40388:	70 91 a5 20 	lds	r23, 0x20A5
   4038c:	8e ea       	ldi	r24, 0xAE	; 174
   4038e:	90 e2       	ldi	r25, 0x20	; 32
   40390:	88 d6       	rcall	.+3344   	; 0x410a2 <udd_set_setup_payload>
	return true;
}
   40392:	81 e0       	ldi	r24, 0x01	; 1
   40394:	08 95       	ret

00040396 <udi_dfu_atmel_mem_send_last_add>:


static bool udi_dfu_atmel_mem_send_last_add(void)
{
	// Send last checked address
	udi_dfu_atmel_buf_trans[0] = (uint8_t)(udi_dfu_atmel_mem_add>>8);
   40396:	80 91 a6 20 	lds	r24, 0x20A6
   4039a:	90 91 a7 20 	lds	r25, 0x20A7
   4039e:	90 93 ae 20 	sts	0x20AE, r25
	udi_dfu_atmel_buf_trans[1] = (uint8_t)udi_dfu_atmel_mem_add;
   403a2:	80 93 af 20 	sts	0x20AF, r24
	// Init buffer to transfer
	udd_set_setup_payload( udi_dfu_atmel_buf_trans, 2);
   403a6:	62 e0       	ldi	r22, 0x02	; 2
   403a8:	70 e0       	ldi	r23, 0x00	; 0
   403aa:	8e ea       	ldi	r24, 0xAE	; 174
   403ac:	90 e2       	ldi	r25, 0x20	; 32
   403ae:	79 d6       	rcall	.+3314   	; 0x410a2 <udd_set_setup_payload>
	return true;
}
   403b0:	81 e0       	ldi	r24, 0x01	; 1
   403b2:	08 95       	ret

000403b4 <udi_dfu_atmel_setup>:


bool udi_dfu_atmel_setup(void)
{
	//** Interface requests
	if (Udd_setup_type() != USB_REQ_TYPE_CLASS) {
   403b4:	80 91 63 29 	lds	r24, 0x2963
   403b8:	98 2f       	mov	r25, r24
   403ba:	90 76       	andi	r25, 0x60	; 96
   403bc:	90 32       	cpi	r25, 0x20	; 32
   403be:	09 f0       	breq	.+2      	; 0x403c2 <udi_dfu_atmel_setup+0xe>
   403c0:	44 c0       	rjmp	.+136    	; 0x4044a <udi_dfu_atmel_setup+0x96>
		return false; // Only class request decoded
	}

	if (Udd_setup_is_in()) {
   403c2:	88 23       	and	r24, r24
   403c4:	ac f4       	brge	.+42     	; 0x403f0 <udi_dfu_atmel_setup+0x3c>
		// Requests Class Interface Get
		switch (udd_g_ctrlreq.req.bRequest) {
   403c6:	80 91 64 29 	lds	r24, 0x2964
   403ca:	82 30       	cpi	r24, 0x02	; 2
   403cc:	49 f0       	breq	.+18     	; 0x403e0 <udi_dfu_atmel_setup+0x2c>
   403ce:	83 30       	cpi	r24, 0x03	; 3
   403d0:	a1 f5       	brne	.+104    	; 0x4043a <udi_dfu_atmel_setup+0x86>
			}
#  endif
#endif
			Assert(udd_g_ctrlreq.req.wValue==0);
			Assert(sizeof(udi_dfu_atmel_status)==udd_g_ctrlreq.req.wLength);
			udd_set_setup_payload(
   403d2:	66 e0       	ldi	r22, 0x06	; 6
   403d4:	70 e0       	ldi	r23, 0x00	; 0
   403d6:	8e ee       	ldi	r24, 0xEE	; 238
   403d8:	98 e2       	ldi	r25, 0x28	; 40
   403da:	63 d6       	rcall	.+3270   	; 0x410a2 <udd_set_setup_payload>
					(uint8_t *) & udi_dfu_atmel_status,
					sizeof(udi_dfu_atmel_status));
			return true;
   403dc:	81 e0       	ldi	r24, 0x01	; 1
   403de:	08 95       	ret
#  ifdef UDI_DFU_ATMEL_PROTOCOL_2_SPLIT_ERASE_CHIP
			Assert( !udi_dfu_atmel_erase_running );
#  endif
#endif
			Assert(DFU_STATE_DFUERROR != udi_dfu_atmel_status.bState);
			if (NULL != udi_dfu_atmel_upload_callback) {
   403e0:	e0 91 ab 20 	lds	r30, 0x20AB
   403e4:	f0 91 ac 20 	lds	r31, 0x20AC
   403e8:	30 97       	sbiw	r30, 0x00	; 0
   403ea:	39 f1       	breq	.+78     	; 0x4043a <udi_dfu_atmel_setup+0x86>
				return udi_dfu_atmel_upload_callback();
   403ec:	19 95       	eicall
   403ee:	08 95       	ret
#  endif
#endif

	if (Udd_setup_is_out()) {
		// Requests Class Interface Set
		switch (udd_g_ctrlreq.req.bRequest) {
   403f0:	80 91 64 29 	lds	r24, 0x2964
   403f4:	81 30       	cpi	r24, 0x01	; 1
   403f6:	29 f0       	breq	.+10     	; 0x40402 <udi_dfu_atmel_setup+0x4e>
   403f8:	84 30       	cpi	r24, 0x04	; 4
   403fa:	f9 f4       	brne	.+62     	; 0x4043a <udi_dfu_atmel_setup+0x86>
		case USB_REQ_DFU_CLRSTATUS:
			Assert(udd_g_ctrlreq.req.wValue==0);
			Assert(udd_g_ctrlreq.req.wLength==0);
			udi_dfu_atmel_reset_protocol();
   403fc:	46 df       	rcall	.-372    	; 0x4028a <udi_dfu_atmel_reset_protocol>
			return true;
   403fe:	81 e0       	ldi	r24, 0x01	; 1
   40400:	08 95       	ret
			// DNLOAD request including Atmel command fields
			// and data for write operation.
			// For read operation, the data are sent in the next UPLOAD request
		case USB_REQ_DFU_DNLOAD:
			// Check if a reset has been requested
			if (udi_dfu_atmel_reset) {
   40402:	80 91 aa 20 	lds	r24, 0x20AA
   40406:	88 23       	and	r24, r24
   40408:	59 f0       	breq	.+22     	; 0x40420 <udi_dfu_atmel_setup+0x6c>
				// Remove force ISP before a reset CPU to start Application
				isp_force_boot_isp(false);
   4040a:	80 e0       	ldi	r24, 0x00	; 0
   4040c:	1e 94 1f 0a 	call	0x4143e	; 0x4143e <isp_force_boot_isp>
				// Then this DNLOAD DFU request must be empty (0==wLength)
				// and valid the reset application command.
				// Valid SETUP request and reset application via request callback.
				udd_g_ctrlreq.callback = isp_start_appli;
   40410:	80 e1       	ldi	r24, 0x10	; 16
   40412:	9a e0       	ldi	r25, 0x0A	; 10
   40414:	80 93 6f 29 	sts	0x296F, r24
   40418:	90 93 70 29 	sts	0x2970, r25
				return true;
   4041c:	81 e0       	ldi	r24, 0x01	; 1
   4041e:	08 95       	ret
			Assert(udd_g_ctrlreq.req.wLength!=0);

			// The first packet contains the command
			// after this packet the over_under_run callback can be called
			// if the Host want to send more data to device
			udd_set_setup_payload(
   40420:	60 e4       	ldi	r22, 0x40	; 64
   40422:	70 e0       	ldi	r23, 0x00	; 0
   40424:	8e ea       	ldi	r24, 0xAE	; 174
   40426:	98 e2       	ldi	r25, 0x28	; 40
   40428:	3c d6       	rcall	.+3192   	; 0x410a2 <udd_set_setup_payload>
				(uint8_t *) & udi_dfu_flip_msg.payload,
				sizeof(udi_dfu_flip_msg)),
			// Called when the first packet is received
			// before continuing DATA phase or start ZLP phase
			udd_g_ctrlreq.over_under_run = udi_dfu_flip_msg_decode;
   4042a:	87 e2       	ldi	r24, 0x27	; 39
   4042c:	92 e0       	ldi	r25, 0x02	; 2
   4042e:	80 93 71 29 	sts	0x2971, r24
   40432:	90 93 72 29 	sts	0x2972, r25
			// Note udd_g_ctrlreq.callback is updated
			// by udi_dfu_flip_msg_decode() before ZLP phase
			return true;
   40436:	81 e0       	ldi	r24, 0x01	; 1
   40438:	08 95       	ret
		}
	}
	// Unknown request
	udi_dfu_atmel_status.bStatus = DFU_STATUS_ERRSTALLEDPK;
   4043a:	8f e0       	ldi	r24, 0x0F	; 15
   4043c:	80 93 ee 28 	sts	0x28EE, r24
	udi_dfu_atmel_status.bState = DFU_STATE_DFUERROR;
   40440:	8a e0       	ldi	r24, 0x0A	; 10
   40442:	80 93 f2 28 	sts	0x28F2, r24
	return false;
   40446:	80 e0       	ldi	r24, 0x00	; 0
   40448:	08 95       	ret

bool udi_dfu_atmel_setup(void)
{
	//** Interface requests
	if (Udd_setup_type() != USB_REQ_TYPE_CLASS) {
		return false; // Only class request decoded
   4044a:	80 e0       	ldi	r24, 0x00	; 0
	}
	// Unknown request
	udi_dfu_atmel_status.bStatus = DFU_STATUS_ERRSTALLEDPK;
	udi_dfu_atmel_status.bState = DFU_STATE_DFUERROR;
	return false;
}
   4044c:	08 95       	ret

0004044e <udi_dfu_flip_msg_decode>:


#if (FLIP_PROTOCOL_VERSION == FLIP_PROTOCOL_VERSION_2)

static bool udi_dfu_flip_msg_decode(void)
{
   4044e:	0f 93       	push	r16
   40450:	1f 93       	push	r17
   40452:	cf 93       	push	r28
	// By default no callback initialized
	// By default request states are success and finish
	udi_dfu_atmel_reset_protocol();
   40454:	1a df       	rcall	.-460    	; 0x4028a <udi_dfu_atmel_reset_protocol>
	udi_dfu_atmel_upload_callback = NULL;
   40456:	10 92 ab 20 	sts	0x20AB, r1
   4045a:	10 92 ac 20 	sts	0x20AC, r1

	// To restart ISP in case of USB cable is unplugged during program load
	isp_force_boot_isp(true);
   4045e:	81 e0       	ldi	r24, 0x01	; 1
   40460:	ee d7       	rcall	.+4060   	; 0x4143e <isp_force_boot_isp>

	// Decode Atmel command ID
	if (CAT_CMD( udi_dfu_flip_msg.msg.group, udi_dfu_flip_msg.msg.cmd_id) ==
   40462:	80 91 ae 28 	lds	r24, 0x28AE
   40466:	90 e0       	ldi	r25, 0x00	; 0
   40468:	98 2f       	mov	r25, r24
   4046a:	88 27       	eor	r24, r24
   4046c:	20 91 af 28 	lds	r18, 0x28AF
   40470:	82 2b       	or	r24, r18
   40472:	81 15       	cp	r24, r1
   40474:	21 e0       	ldi	r18, 0x01	; 1
   40476:	92 07       	cpc	r25, r18
   40478:	89 f5       	brne	.+98     	; 0x404dc <udi_dfu_flip_msg_decode+0x8e>
}

static bool udi_dfu_atmel_program(void)
{
	// Check list before start memory programming
	if (udi_dfu_atmel_security && udi_dfu_atmel_mem_b_protected) {
   4047a:	80 91 a9 20 	lds	r24, 0x20A9
   4047e:	88 23       	and	r24, r24
   40480:	61 f0       	breq	.+24     	; 0x4049a <udi_dfu_flip_msg_decode+0x4c>
   40482:	80 91 a8 20 	lds	r24, 0x20A8
   40486:	88 23       	and	r24, r24
   40488:	41 f0       	breq	.+16     	; 0x4049a <udi_dfu_flip_msg_decode+0x4c>
	udi_dfu_atmel_mem_sel = *isp_memories.mem[mem_num];
}

static bool udi_dfu_atmel_mem_protected(void)
{
	udi_dfu_atmel_status.bStatus = DFU_STATUS_ERRWRITE;
   4048a:	83 e0       	ldi	r24, 0x03	; 3
   4048c:	80 93 ee 28 	sts	0x28EE, r24
	udi_dfu_atmel_status.bState = DFU_STATE_DFUIDLE;
   40490:	82 e0       	ldi	r24, 0x02	; 2
   40492:	80 93 f2 28 	sts	0x28F2, r24
static bool udi_dfu_atmel_program(void)
{
	// Check list before start memory programming
	if (udi_dfu_atmel_security && udi_dfu_atmel_mem_b_protected) {
		// Security enabled
		return udi_dfu_atmel_mem_protected();
   40496:	c0 e0       	ldi	r28, 0x00	; 0
   40498:	20 c1       	rjmp	.+576    	; 0x406da <udi_dfu_flip_msg_decode+0x28c>
	}
	if (!udi_dfu_atmel_mem_sel.fnct_write) {
   4049a:	80 91 a2 20 	lds	r24, 0x20A2
   4049e:	90 91 a3 20 	lds	r25, 0x20A3
   404a2:	89 2b       	or	r24, r25
   404a4:	41 f4       	brne	.+16     	; 0x404b6 <udi_dfu_flip_msg_decode+0x68>
		udi_dfu_atmel_status.bStatus = DFU_STATUS_ERRWRITE;
   404a6:	83 e0       	ldi	r24, 0x03	; 3
   404a8:	80 93 ee 28 	sts	0x28EE, r24
		udi_dfu_atmel_status.bState = DFU_STATE_DFUERROR;
   404ac:	8a e0       	ldi	r24, 0x0A	; 10
   404ae:	80 93 f2 28 	sts	0x28F2, r24
		return false; // Write memory not available
   404b2:	c0 e0       	ldi	r28, 0x00	; 0
   404b4:	12 c1       	rjmp	.+548    	; 0x406da <udi_dfu_flip_msg_decode+0x28c>
	}
	if (!udi_dfu_atmel_mem_getaddr(&udi_dfu_flip_msg.msg.arg[0]))
   404b6:	80 eb       	ldi	r24, 0xB0	; 176
   404b8:	98 e2       	ldi	r25, 0x28	; 40
   404ba:	fd de       	rcall	.-518    	; 0x402b6 <udi_dfu_atmel_mem_getaddr>
   404bc:	c8 2f       	mov	r28, r24
   404be:	88 23       	and	r24, r24
   404c0:	09 f4       	brne	.+2      	; 0x404c4 <udi_dfu_flip_msg_decode+0x76>
   404c2:	0b c1       	rjmp	.+534    	; 0x406da <udi_dfu_flip_msg_decode+0x28c>
		return false; // Bad Range

	// Init buffer to fill during next DATA phase of request
	udd_set_setup_payload(
   404c4:	60 e0       	ldi	r22, 0x00	; 0
   404c6:	78 e0       	ldi	r23, 0x08	; 8
   404c8:	8e ea       	ldi	r24, 0xAE	; 174
   404ca:	90 e2       	ldi	r25, 0x20	; 32
   404cc:	ea d5       	rcall	.+3028   	; 0x410a2 <udd_set_setup_payload>
		udi_dfu_atmel_buf_trans,
		DFU_ATMEL_BUF_TRANS_SIZE);
	// Init callback called after buffer filled
	udd_g_ctrlreq.over_under_run = udi_dfu_atmel_mem_write;
   404ce:	80 e9       	ldi	r24, 0x90	; 144
   404d0:	91 e0       	ldi	r25, 0x01	; 1
   404d2:	80 93 71 29 	sts	0x2971, r24
   404d6:	90 93 72 29 	sts	0x2972, r25
	isp_force_boot_isp(true);

	// Decode Atmel command ID
	if (CAT_CMD( udi_dfu_flip_msg.msg.group, udi_dfu_flip_msg.msg.cmd_id) ==
			CAT_CMD( FLIP_V2_CMD_GRP_DNLOAD, FLIP_V2_CMD_PROGRAM_START)) {
		return udi_dfu_atmel_program();
   404da:	ff c0       	rjmp	.+510    	; 0x406da <udi_dfu_flip_msg_decode+0x28c>
	}
	if (CAT_CMD( udi_dfu_flip_msg.msg.group, udi_dfu_flip_msg.msg.cmd_id) ==
   404dc:	81 15       	cp	r24, r1
   404de:	23 e0       	ldi	r18, 0x03	; 3
   404e0:	92 07       	cpc	r25, r18
   404e2:	59 f5       	brne	.+86     	; 0x4053a <udi_dfu_flip_msg_decode+0xec>
}

static bool udi_dfu_atmel_read(void)
{
	// Check before decoding the command
	if (!udi_dfu_atmel_mem_getaddr(&udi_dfu_flip_msg.msg.arg[0]))
   404e4:	80 eb       	ldi	r24, 0xB0	; 176
   404e6:	98 e2       	ldi	r25, 0x28	; 40
   404e8:	e6 de       	rcall	.-564    	; 0x402b6 <udi_dfu_atmel_mem_getaddr>
   404ea:	c8 2f       	mov	r28, r24
   404ec:	88 23       	and	r24, r24
   404ee:	09 f4       	brne	.+2      	; 0x404f2 <udi_dfu_flip_msg_decode+0xa4>
   404f0:	f4 c0       	rjmp	.+488    	; 0x406da <udi_dfu_flip_msg_decode+0x28c>
		return false; // Range bad

	if (!udi_dfu_atmel_mem_sel.fnct_read) {
   404f2:	20 91 a0 20 	lds	r18, 0x20A0
   404f6:	30 91 a1 20 	lds	r19, 0x20A1
   404fa:	23 2b       	or	r18, r19
   404fc:	41 f4       	brne	.+16     	; 0x4050e <udi_dfu_flip_msg_decode+0xc0>
		udi_dfu_atmel_status.bStatus = DFU_STATUS_ERRWRITE;
   404fe:	83 e0       	ldi	r24, 0x03	; 3
   40500:	80 93 ee 28 	sts	0x28EE, r24
		udi_dfu_atmel_status.bState = DFU_STATE_DFUERROR;
   40504:	8a e0       	ldi	r24, 0x0A	; 10
   40506:	80 93 f2 28 	sts	0x28F2, r24
		return false; // Read memory not available
   4050a:	c0 e0       	ldi	r28, 0x00	; 0
   4050c:	e6 c0       	rjmp	.+460    	; 0x406da <udi_dfu_flip_msg_decode+0x28c>
	}

	if (udi_dfu_atmel_security && udi_dfu_atmel_mem_b_protected) {
   4050e:	80 91 a9 20 	lds	r24, 0x20A9
   40512:	88 23       	and	r24, r24
   40514:	59 f0       	breq	.+22     	; 0x4052c <udi_dfu_flip_msg_decode+0xde>
   40516:	80 91 a8 20 	lds	r24, 0x20A8
   4051a:	88 23       	and	r24, r24
   4051c:	39 f0       	breq	.+14     	; 0x4052c <udi_dfu_flip_msg_decode+0xde>
		// Memory security then remove read callback by protected callback
		udi_dfu_atmel_upload_callback = udi_dfu_atmel_mem_protected;
   4051e:	83 e5       	ldi	r24, 0x53	; 83
   40520:	91 e0       	ldi	r25, 0x01	; 1
   40522:	80 93 ab 20 	sts	0x20AB, r24
   40526:	90 93 ac 20 	sts	0x20AC, r25
   4052a:	d7 c0       	rjmp	.+430    	; 0x406da <udi_dfu_flip_msg_decode+0x28c>
	}else{
		udi_dfu_atmel_upload_callback = udi_dfu_atmel_mem_read;
   4052c:	23 eb       	ldi	r18, 0xB3	; 179
   4052e:	31 e0       	ldi	r19, 0x01	; 1
   40530:	20 93 ab 20 	sts	0x20AB, r18
   40534:	30 93 ac 20 	sts	0x20AC, r19
			CAT_CMD( FLIP_V2_CMD_GRP_DNLOAD, FLIP_V2_CMD_PROGRAM_START)) {
		return udi_dfu_atmel_program();
	}
	if (CAT_CMD( udi_dfu_flip_msg.msg.group, udi_dfu_flip_msg.msg.cmd_id) ==
			CAT_CMD( FLIP_V2_CMD_GRP_UPLOAD, FLIP_V2_CMD_READ_MEMORY)) {
		return udi_dfu_atmel_read();
   40538:	d0 c0       	rjmp	.+416    	; 0x406da <udi_dfu_flip_msg_decode+0x28c>
	}
	if (CAT_CMD( udi_dfu_flip_msg.msg.group, udi_dfu_flip_msg.msg.cmd_id) ==
   4053a:	81 30       	cpi	r24, 0x01	; 1
   4053c:	23 e0       	ldi	r18, 0x03	; 3
   4053e:	92 07       	cpc	r25, r18
   40540:	09 f0       	breq	.+2      	; 0x40544 <udi_dfu_flip_msg_decode+0xf6>
   40542:	81 c0       	rjmp	.+258    	; 0x40646 <udi_dfu_flip_msg_decode+0x1f8>
}

static bool udi_dfu_atmel_blankcheck(void)
{
	// Check before decoding the command
	if (!udi_dfu_atmel_mem_getaddr(&udi_dfu_flip_msg.msg.arg[0]))
   40544:	80 eb       	ldi	r24, 0xB0	; 176
   40546:	98 e2       	ldi	r25, 0x28	; 40
   40548:	b6 de       	rcall	.-660    	; 0x402b6 <udi_dfu_atmel_mem_getaddr>
   4054a:	c8 2f       	mov	r28, r24
   4054c:	88 23       	and	r24, r24
   4054e:	09 f4       	brne	.+2      	; 0x40552 <udi_dfu_flip_msg_decode+0x104>
   40550:	c4 c0       	rjmp	.+392    	; 0x406da <udi_dfu_flip_msg_decode+0x28c>
		return false; // Range bad

	if (!udi_dfu_atmel_mem_sel.fnct_read) {
   40552:	20 91 a0 20 	lds	r18, 0x20A0
   40556:	30 91 a1 20 	lds	r19, 0x20A1
   4055a:	23 2b       	or	r18, r19
   4055c:	41 f4       	brne	.+16     	; 0x4056e <udi_dfu_flip_msg_decode+0x120>
		udi_dfu_atmel_status.bStatus = DFU_STATUS_ERRWRITE;
   4055e:	83 e0       	ldi	r24, 0x03	; 3
   40560:	80 93 ee 28 	sts	0x28EE, r24
		udi_dfu_atmel_status.bState = DFU_STATE_DFUERROR;
   40564:	8a e0       	ldi	r24, 0x0A	; 10
   40566:	80 93 f2 28 	sts	0x28F2, r24
		return false; // Read memory not available
   4056a:	c0 e0       	ldi	r28, 0x00	; 0
   4056c:	b6 c0       	rjmp	.+364    	; 0x406da <udi_dfu_flip_msg_decode+0x28c>
	uint16_t packet_size;

	// Patch for part with 64KB of flash
	// The (uint16_t)udi_dfu_atmel_mem_nb_data is 0 for 64KB
	// This avoid to use a uint32_t and increase code.
	if (!udi_dfu_atmel_mem_nb_data) {
   4056e:	20 91 a4 20 	lds	r18, 0x20A4
   40572:	30 91 a5 20 	lds	r19, 0x20A5
   40576:	21 15       	cp	r18, r1
   40578:	31 05       	cpc	r19, r1
   4057a:	b1 f4       	brne	.+44     	; 0x405a8 <udi_dfu_flip_msg_decode+0x15a>
		udi_dfu_atmel_mem_nb_data = (64*1024L)-DFU_ATMEL_BUF_TRANS_SIZE;
   4057c:	80 e0       	ldi	r24, 0x00	; 0
   4057e:	98 ef       	ldi	r25, 0xF8	; 248
   40580:	80 93 a4 20 	sts	0x20A4, r24
   40584:	90 93 a5 20 	sts	0x20A5, r25
			DFU_ATMEL_BUF_TRANS_SIZE);
		udi_dfu_atmel_mem_nb_data -= packet_size;

udi_dfu_atmel_mem_check_patch:
		// Fill buffer from memory
		udi_dfu_atmel_mem_sel.fnct_read(udi_dfu_atmel_buf_trans,
   40588:	60 91 a6 20 	lds	r22, 0x20A6
   4058c:	70 91 a7 20 	lds	r23, 0x20A7
   40590:	e0 91 a0 20 	lds	r30, 0x20A0
   40594:	f0 91 a1 20 	lds	r31, 0x20A1
   40598:	40 e0       	ldi	r20, 0x00	; 0
   4059a:	58 e0       	ldi	r21, 0x08	; 8
   4059c:	8e ea       	ldi	r24, 0xAE	; 174
   4059e:	90 e2       	ldi	r25, 0x20	; 32
   405a0:	19 95       	eicall
			udi_dfu_atmel_mem_add, packet_size);

		// Check buffer content
		ptr_buf = udi_dfu_atmel_buf_trans;
		while (packet_size--) {
   405a2:	4f ef       	ldi	r20, 0xFF	; 255
   405a4:	57 e0       	ldi	r21, 0x07	; 7
   405a6:	1f c0       	rjmp	.+62     	; 0x405e6 <udi_dfu_flip_msg_decode+0x198>
		goto udi_dfu_atmel_mem_check_patch;
	}

	while (udi_dfu_atmel_mem_nb_data) {
		// Compute buffer to read
		packet_size = min(udi_dfu_atmel_mem_nb_data,
   405a8:	89 01       	movw	r16, r18
   405aa:	21 30       	cpi	r18, 0x01	; 1
   405ac:	88 e0       	ldi	r24, 0x08	; 8
   405ae:	38 07       	cpc	r19, r24
   405b0:	10 f0       	brcs	.+4      	; 0x405b6 <udi_dfu_flip_msg_decode+0x168>
   405b2:	00 e0       	ldi	r16, 0x00	; 0
   405b4:	18 e0       	ldi	r17, 0x08	; 8
			DFU_ATMEL_BUF_TRANS_SIZE);
		udi_dfu_atmel_mem_nb_data -= packet_size;
   405b6:	20 1b       	sub	r18, r16
   405b8:	31 0b       	sbc	r19, r17
   405ba:	20 93 a4 20 	sts	0x20A4, r18
   405be:	30 93 a5 20 	sts	0x20A5, r19

udi_dfu_atmel_mem_check_patch:
		// Fill buffer from memory
		udi_dfu_atmel_mem_sel.fnct_read(udi_dfu_atmel_buf_trans,
   405c2:	60 91 a6 20 	lds	r22, 0x20A6
   405c6:	70 91 a7 20 	lds	r23, 0x20A7
   405ca:	e0 91 a0 20 	lds	r30, 0x20A0
   405ce:	f0 91 a1 20 	lds	r31, 0x20A1
   405d2:	a8 01       	movw	r20, r16
   405d4:	8e ea       	ldi	r24, 0xAE	; 174
   405d6:	90 e2       	ldi	r25, 0x20	; 32
   405d8:	19 95       	eicall
			udi_dfu_atmel_mem_add, packet_size);

		// Check buffer content
		ptr_buf = udi_dfu_atmel_buf_trans;
		while (packet_size--) {
   405da:	01 15       	cp	r16, r1
   405dc:	11 05       	cpc	r17, r1
   405de:	51 f1       	breq	.+84     	; 0x40634 <udi_dfu_flip_msg_decode+0x1e6>
   405e0:	a8 01       	movw	r20, r16
   405e2:	41 50       	subi	r20, 0x01	; 1
   405e4:	51 09       	sbc	r21, r1
			if (*ptr_buf++ != 0xFF) {
   405e6:	80 91 ae 20 	lds	r24, 0x20AE
   405ea:	8f 3f       	cpi	r24, 0xFF	; 255
   405ec:	91 f0       	breq	.+36     	; 0x40612 <udi_dfu_flip_msg_decode+0x1c4>
   405ee:	07 c0       	rjmp	.+14     	; 0x405fe <udi_dfu_flip_msg_decode+0x1b0>
   405f0:	81 91       	ld	r24, Z+
   405f2:	8f 3f       	cpi	r24, 0xFF	; 255
   405f4:	b1 f0       	breq	.+44     	; 0x40622 <udi_dfu_flip_msg_decode+0x1d4>
   405f6:	20 93 a6 20 	sts	0x20A6, r18
   405fa:	30 93 a7 20 	sts	0x20A7, r19
				// Error, don't stall request but:
				// Update DFU status
				udi_dfu_atmel_status.bStatus = DFU_STATUS_ERRCHECK_ERASED;
   405fe:	85 e0       	ldi	r24, 0x05	; 5
   40600:	80 93 ee 28 	sts	0x28EE, r24
				// Send last address checked in next Upload command
				udi_dfu_atmel_upload_callback = udi_dfu_atmel_mem_send_last_add;
   40604:	8b ec       	ldi	r24, 0xCB	; 203
   40606:	91 e0       	ldi	r25, 0x01	; 1
   40608:	80 93 ab 20 	sts	0x20AB, r24
   4060c:	90 93 ac 20 	sts	0x20AC, r25
   40610:	64 c0       	rjmp	.+200    	; 0x406da <udi_dfu_flip_msg_decode+0x28c>
   40612:	20 91 a6 20 	lds	r18, 0x20A6
   40616:	30 91 a7 20 	lds	r19, 0x20A7
   4061a:	ef ea       	ldi	r30, 0xAF	; 175
   4061c:	f0 e2       	ldi	r31, 0x20	; 32
   4061e:	41 55       	subi	r20, 0x51	; 81
   40620:	5f 4d       	sbci	r21, 0xDF	; 223
				return;
			}
			udi_dfu_atmel_mem_add++;
   40622:	2f 5f       	subi	r18, 0xFF	; 255
   40624:	3f 4f       	sbci	r19, 0xFF	; 255
		udi_dfu_atmel_mem_sel.fnct_read(udi_dfu_atmel_buf_trans,
			udi_dfu_atmel_mem_add, packet_size);

		// Check buffer content
		ptr_buf = udi_dfu_atmel_buf_trans;
		while (packet_size--) {
   40626:	e4 17       	cp	r30, r20
   40628:	f5 07       	cpc	r31, r21
   4062a:	11 f7       	brne	.-60     	; 0x405f0 <udi_dfu_flip_msg_decode+0x1a2>
   4062c:	20 93 a6 20 	sts	0x20A6, r18
   40630:	30 93 a7 20 	sts	0x20A7, r19
		udi_dfu_atmel_mem_nb_data = (64*1024L)-DFU_ATMEL_BUF_TRANS_SIZE;
		packet_size = DFU_ATMEL_BUF_TRANS_SIZE;
		goto udi_dfu_atmel_mem_check_patch;
	}

	while (udi_dfu_atmel_mem_nb_data) {
   40634:	20 91 a4 20 	lds	r18, 0x20A4
   40638:	30 91 a5 20 	lds	r19, 0x20A5
   4063c:	21 15       	cp	r18, r1
   4063e:	31 05       	cpc	r19, r1
   40640:	09 f4       	brne	.+2      	; 0x40644 <udi_dfu_flip_msg_decode+0x1f6>
   40642:	4b c0       	rjmp	.+150    	; 0x406da <udi_dfu_flip_msg_decode+0x28c>
   40644:	b1 cf       	rjmp	.-158    	; 0x405a8 <udi_dfu_flip_msg_decode+0x15a>
	}
	if (CAT_CMD( udi_dfu_flip_msg.msg.group, udi_dfu_flip_msg.msg.cmd_id) ==
			CAT_CMD( FLIP_V2_CMD_GRP_UPLOAD, FLIP_V2_CMD_BLANK_CHECK)) {
		return udi_dfu_atmel_blankcheck();
	}
	if (CAT_CMD( udi_dfu_flip_msg.msg.group, udi_dfu_flip_msg.msg.cmd_id) ==
   40646:	81 15       	cp	r24, r1
   40648:	24 e0       	ldi	r18, 0x04	; 4
   4064a:	92 07       	cpc	r25, r18
   4064c:	41 f4       	brne	.+16     	; 0x4065e <udi_dfu_flip_msg_decode+0x210>
		udi_dfu_atmel_erase_running = true;
		udi_dfu_atmel_status.bStatus = DFU_STATUS_ERRNOTDONE;
		udi_dfu_atmel_status.bState = DFU_STATE_DFUDNBUSY;
	}
#else
	if (!isp_erase_chip()) {
   4064e:	da d6       	rcall	.+3508   	; 0x41404 <isp_erase_chip>
   40650:	c8 2f       	mov	r28, r24
   40652:	88 23       	and	r24, r24
   40654:	09 f4       	brne	.+2      	; 0x40658 <udi_dfu_flip_msg_decode+0x20a>
   40656:	41 c0       	rjmp	.+130    	; 0x406da <udi_dfu_flip_msg_decode+0x28c>
		return false;
	}
	// Erase finish
	udi_dfu_atmel_security = false;
   40658:	10 92 a9 20 	sts	0x20A9, r1
			CAT_CMD( FLIP_V2_CMD_GRP_UPLOAD, FLIP_V2_CMD_BLANK_CHECK)) {
		return udi_dfu_atmel_blankcheck();
	}
	if (CAT_CMD( udi_dfu_flip_msg.msg.group, udi_dfu_flip_msg.msg.cmd_id) ==
			CAT_CMD( FLIP_V2_CMD_GRP_EXEC, FLIP_V2_CMD_ERASE)) {
		return udi_dfu_atmel_erase_chip();
   4065c:	3e c0       	rjmp	.+124    	; 0x406da <udi_dfu_flip_msg_decode+0x28c>
	}
	if (CAT_CMD( udi_dfu_flip_msg.msg.group, udi_dfu_flip_msg.msg.cmd_id) ==
   4065e:	83 30       	cpi	r24, 0x03	; 3
   40660:	24 e0       	ldi	r18, 0x04	; 4
   40662:	92 07       	cpc	r25, r18
   40664:	29 f4       	brne	.+10     	; 0x40670 <udi_dfu_flip_msg_decode+0x222>
static void udi_dfu_atmel_start(void)
{
	// Start application reset after next DNLOAD request
	Assert( (udi_dfu_flip_msg.msg.arg[0] == FLIP_V2_CMD_START_APPLI_ARG_RESET)
		|| (udi_dfu_flip_msg.msg.arg[0] == FLIP_V2_CMD_START_APPLI_ARG_NO_RESET));
	udi_dfu_atmel_reset = true;
   40666:	81 e0       	ldi	r24, 0x01	; 1
   40668:	80 93 aa 20 	sts	0x20AA, r24
		return udi_dfu_atmel_erase_chip();
	}
	if (CAT_CMD( udi_dfu_flip_msg.msg.group, udi_dfu_flip_msg.msg.cmd_id) ==
			CAT_CMD( FLIP_V2_CMD_GRP_EXEC, FLIP_V2_CMD_START_APPLI)) {
		udi_dfu_atmel_start();
		return true;
   4066c:	c1 e0       	ldi	r28, 0x01	; 1
   4066e:	35 c0       	rjmp	.+106    	; 0x406da <udi_dfu_flip_msg_decode+0x28c>
	}
	if (CAT_CMD( udi_dfu_flip_msg.msg.group, udi_dfu_flip_msg.msg.cmd_id) ==
   40670:	83 30       	cpi	r24, 0x03	; 3
   40672:	96 40       	sbci	r25, 0x06	; 6
   40674:	89 f5       	brne	.+98     	; 0x406d8 <udi_dfu_flip_msg_decode+0x28a>
	udi_dfu_atmel_reset = true;
}

static bool udi_dfu_atmel_select_memory(void)
{
	switch (udi_dfu_flip_msg.msg.arg[0]) {
   40676:	80 91 b0 28 	lds	r24, 0x28B0
   4067a:	81 11       	cpse	r24, r1
   4067c:	2b c0       	rjmp	.+86     	; 0x406d4 <udi_dfu_flip_msg_decode+0x286>
	case FLIP_V2_CMD_SELECT_MEMORY_ARG_UNIT:
		if (ISP_MEM_COUNT <= udi_dfu_flip_msg.msg.arg[1]) {
   4067e:	e0 91 b1 28 	lds	r30, 0x28B1
   40682:	e1 31       	cpi	r30, 0x11	; 17
   40684:	40 f0       	brcs	.+16     	; 0x40696 <udi_dfu_flip_msg_decode+0x248>
			udi_dfu_atmel_status.bStatus = DFU_STATUS_ERRADDRESS;
   40686:	88 e0       	ldi	r24, 0x08	; 8
   40688:	80 93 ee 28 	sts	0x28EE, r24
			udi_dfu_atmel_status.bState = DFU_STATE_DFUERROR;
   4068c:	8a e0       	ldi	r24, 0x0A	; 10
   4068e:	80 93 f2 28 	sts	0x28F2, r24
			return false;  // Memory id error
   40692:	c0 e0       	ldi	r28, 0x00	; 0
   40694:	22 c0       	rjmp	.+68     	; 0x406da <udi_dfu_flip_msg_decode+0x28c>
{
#if (FLIP_PROTOCOL_VERSION == FLIP_PROTOCOL_VERSION_2)
	if((mem_num!=ISP_MEM_CONFIGURATION)
	&&(mem_num!=ISP_MEM_SECURITY)
	&&(mem_num!=ISP_MEM_BOOTLOADER)
	&&(mem_num!=ISP_MEM_SIGNATURE)) {
   40696:	8e ef       	ldi	r24, 0xFE	; 254
   40698:	8e 0f       	add	r24, r30


static void udi_dfu_atmel_sel_mem( uint8_t mem_num )
{
#if (FLIP_PROTOCOL_VERSION == FLIP_PROTOCOL_VERSION_2)
	if((mem_num!=ISP_MEM_CONFIGURATION)
   4069a:	84 30       	cpi	r24, 0x04	; 4
   4069c:	20 f0       	brcs	.+8      	; 0x406a6 <udi_dfu_flip_msg_decode+0x258>
	&&(mem_num!=ISP_MEM_SECURITY)
	&&(mem_num!=ISP_MEM_BOOTLOADER)
	&&(mem_num!=ISP_MEM_SIGNATURE)) {
		udi_dfu_atmel_mem_b_protected = true;
   4069e:	81 e0       	ldi	r24, 0x01	; 1
   406a0:	80 93 a8 20 	sts	0x20A8, r24
   406a4:	02 c0       	rjmp	.+4      	; 0x406aa <udi_dfu_flip_msg_decode+0x25c>
	}else{
		udi_dfu_atmel_mem_b_protected = false;
   406a6:	10 92 a8 20 	sts	0x20A8, r1
	}
#endif
	udi_dfu_atmel_mem_sel = *isp_memories.mem[mem_num];
   406aa:	f0 e0       	ldi	r31, 0x00	; 0
   406ac:	ee 0f       	add	r30, r30
   406ae:	ff 1f       	adc	r31, r31
   406b0:	e0 5b       	subi	r30, 0xB0	; 176
   406b2:	ff 4d       	sbci	r31, 0xDF	; 223
   406b4:	01 90       	ld	r0, Z+
   406b6:	f0 81       	ld	r31, Z
   406b8:	e0 2d       	mov	r30, r0
   406ba:	88 e0       	ldi	r24, 0x08	; 8
   406bc:	ac e9       	ldi	r26, 0x9C	; 156
   406be:	b0 e2       	ldi	r27, 0x20	; 32
   406c0:	01 90       	ld	r0, Z+
   406c2:	0d 92       	st	X+, r0
   406c4:	8a 95       	dec	r24
   406c6:	e1 f7       	brne	.-8      	; 0x406c0 <udi_dfu_flip_msg_decode+0x272>
			udi_dfu_atmel_status.bStatus = DFU_STATUS_ERRADDRESS;
			udi_dfu_atmel_status.bState = DFU_STATE_DFUERROR;
			return false;  // Memory id error
		}
		udi_dfu_atmel_sel_mem(udi_dfu_flip_msg.msg.arg[1]);
		udi_dfu_atmel_mem_add = 0;
   406c8:	10 92 a6 20 	sts	0x20A6, r1
   406cc:	10 92 a7 20 	sts	0x20A7, r1
	default:
		Assert(false);  // Bad command
		break;
	}

	return true;
   406d0:	c1 e0       	ldi	r28, 0x01	; 1
   406d2:	03 c0       	rjmp	.+6      	; 0x406da <udi_dfu_flip_msg_decode+0x28c>
   406d4:	c1 e0       	ldi	r28, 0x01	; 1
		udi_dfu_atmel_start();
		return true;
	}
	if (CAT_CMD( udi_dfu_flip_msg.msg.group, udi_dfu_flip_msg.msg.cmd_id) ==
			CAT_CMD( FLIP_V2_CMD_GRP_SELECT, FLIP_V2_CMD_SELECT_MEMORY)) {
		return udi_dfu_atmel_select_memory();
   406d6:	01 c0       	rjmp	.+2      	; 0x406da <udi_dfu_flip_msg_decode+0x28c>
	}
	return false; // Unknown command
   406d8:	c0 e0       	ldi	r28, 0x00	; 0
}
   406da:	8c 2f       	mov	r24, r28
   406dc:	cf 91       	pop	r28
   406de:	1f 91       	pop	r17
   406e0:	0f 91       	pop	r16
   406e2:	08 95       	ret

000406e4 <udc_update_iface_desc>:
/*! \brief Stop the USB Device stack
 */
void udc_stop(void)
{
	udd_disable();
	udc_reset();
   406e4:	90 91 f9 28 	lds	r25, 0x28F9
   406e8:	99 23       	and	r25, r25
   406ea:	81 f1       	breq	.+96     	; 0x4074c <udc_update_iface_desc+0x68>
   406ec:	e0 91 f7 28 	lds	r30, 0x28F7
   406f0:	f0 91 f8 28 	lds	r31, 0x28F8
   406f4:	01 90       	ld	r0, Z+
   406f6:	f0 81       	ld	r31, Z
   406f8:	e0 2d       	mov	r30, r0
   406fa:	94 81       	ldd	r25, Z+4	; 0x04
   406fc:	89 17       	cp	r24, r25
   406fe:	40 f5       	brcc	.+80     	; 0x40750 <udc_update_iface_desc+0x6c>
   40700:	e0 93 f5 28 	sts	0x28F5, r30
   40704:	f0 93 f6 28 	sts	0x28F6, r31
   40708:	22 81       	ldd	r18, Z+2	; 0x02
   4070a:	33 81       	ldd	r19, Z+3	; 0x03
   4070c:	2e 0f       	add	r18, r30
   4070e:	3f 1f       	adc	r19, r31
   40710:	e2 17       	cp	r30, r18
   40712:	f3 07       	cpc	r31, r19
   40714:	f8 f4       	brcc	.+62     	; 0x40754 <udc_update_iface_desc+0x70>
   40716:	91 81       	ldd	r25, Z+1	; 0x01
   40718:	94 30       	cpi	r25, 0x04	; 4
   4071a:	61 f4       	brne	.+24     	; 0x40734 <udc_update_iface_desc+0x50>
   4071c:	92 81       	ldd	r25, Z+2	; 0x02
   4071e:	98 13       	cpse	r25, r24
   40720:	09 c0       	rjmp	.+18     	; 0x40734 <udc_update_iface_desc+0x50>
   40722:	93 81       	ldd	r25, Z+3	; 0x03
   40724:	96 13       	cpse	r25, r22
   40726:	06 c0       	rjmp	.+12     	; 0x40734 <udc_update_iface_desc+0x50>
   40728:	e0 93 f5 28 	sts	0x28F5, r30
   4072c:	f0 93 f6 28 	sts	0x28F6, r31
   40730:	81 e0       	ldi	r24, 0x01	; 1
   40732:	08 95       	ret
   40734:	90 81       	ld	r25, Z
   40736:	e9 0f       	add	r30, r25
   40738:	f1 1d       	adc	r31, r1
   4073a:	e2 17       	cp	r30, r18
   4073c:	f3 07       	cpc	r31, r19
   4073e:	58 f3       	brcs	.-42     	; 0x40716 <udc_update_iface_desc+0x32>
   40740:	e0 93 f5 28 	sts	0x28F5, r30
   40744:	f0 93 f6 28 	sts	0x28F6, r31
   40748:	80 e0       	ldi	r24, 0x00	; 0
   4074a:	08 95       	ret
   4074c:	80 e0       	ldi	r24, 0x00	; 0
   4074e:	08 95       	ret
   40750:	80 e0       	ldi	r24, 0x00	; 0
   40752:	08 95       	ret
   40754:	80 e0       	ldi	r24, 0x00	; 0
   40756:	08 95       	ret

00040758 <udc_iface_disable>:
   40758:	cf 93       	push	r28
   4075a:	df 93       	push	r29
   4075c:	d8 2f       	mov	r29, r24
   4075e:	60 e0       	ldi	r22, 0x00	; 0
   40760:	c1 df       	rcall	.-126    	; 0x406e4 <udc_update_iface_desc>
   40762:	c8 2f       	mov	r28, r24
   40764:	88 23       	and	r24, r24
   40766:	a9 f0       	breq	.+42     	; 0x40792 <udc_iface_disable+0x3a>
   40768:	a0 91 f7 28 	lds	r26, 0x28F7
   4076c:	b0 91 f8 28 	lds	r27, 0x28F8
   40770:	ed 2f       	mov	r30, r29
   40772:	f0 e0       	ldi	r31, 0x00	; 0
   40774:	ee 0f       	add	r30, r30
   40776:	ff 1f       	adc	r31, r31
   40778:	12 96       	adiw	r26, 0x02	; 2
   4077a:	2d 91       	ld	r18, X+
   4077c:	3c 91       	ld	r19, X
   4077e:	13 97       	sbiw	r26, 0x03	; 3
   40780:	e2 0f       	add	r30, r18
   40782:	f3 1f       	adc	r31, r19
   40784:	01 90       	ld	r0, Z+
   40786:	f0 81       	ld	r31, Z
   40788:	e0 2d       	mov	r30, r0
   4078a:	02 80       	ldd	r0, Z+2	; 0x02
   4078c:	f3 81       	ldd	r31, Z+3	; 0x03
   4078e:	e0 2d       	mov	r30, r0
   40790:	19 95       	eicall
   40792:	8c 2f       	mov	r24, r28
   40794:	df 91       	pop	r29
   40796:	cf 91       	pop	r28
   40798:	08 95       	ret

0004079a <udc_iface_enable>:
   4079a:	cf 93       	push	r28
   4079c:	c8 2f       	mov	r28, r24
   4079e:	a2 df       	rcall	.-188    	; 0x406e4 <udc_update_iface_desc>
   407a0:	88 23       	and	r24, r24
   407a2:	a9 f0       	breq	.+42     	; 0x407ce <udc_iface_enable+0x34>
   407a4:	a0 91 f7 28 	lds	r26, 0x28F7
   407a8:	b0 91 f8 28 	lds	r27, 0x28F8
   407ac:	ec 2f       	mov	r30, r28
   407ae:	f0 e0       	ldi	r31, 0x00	; 0
   407b0:	ee 0f       	add	r30, r30
   407b2:	ff 1f       	adc	r31, r31
   407b4:	12 96       	adiw	r26, 0x02	; 2
   407b6:	8d 91       	ld	r24, X+
   407b8:	9c 91       	ld	r25, X
   407ba:	13 97       	sbiw	r26, 0x03	; 3
   407bc:	e8 0f       	add	r30, r24
   407be:	f9 1f       	adc	r31, r25
   407c0:	01 90       	ld	r0, Z+
   407c2:	f0 81       	ld	r31, Z
   407c4:	e0 2d       	mov	r30, r0
   407c6:	01 90       	ld	r0, Z+
   407c8:	f0 81       	ld	r31, Z
   407ca:	e0 2d       	mov	r30, r0
   407cc:	19 95       	eicall
   407ce:	cf 91       	pop	r28
   407d0:	08 95       	ret

000407d2 <udc_valid_address>:
   407d2:	80 91 65 29 	lds	r24, 0x2965
   407d6:	8f 77       	andi	r24, 0x7F	; 127
   407d8:	5e c4       	rjmp	.+2236   	; 0x41096 <udd_set_address>
   407da:	08 95       	ret

000407dc <udc_start>:
   407dc:	12 c4       	rjmp	.+2084   	; 0x41002 <udd_enable>
   407de:	08 95       	ret

000407e0 <udc_reset>:
   407e0:	cf 93       	push	r28
   407e2:	80 91 f9 28 	lds	r24, 0x28F9
   407e6:	88 23       	and	r24, r24
   407e8:	c1 f0       	breq	.+48     	; 0x4081a <udc_reset+0x3a>
   407ea:	e0 91 f7 28 	lds	r30, 0x28F7
   407ee:	f0 91 f8 28 	lds	r31, 0x28F8
   407f2:	01 90       	ld	r0, Z+
   407f4:	f0 81       	ld	r31, Z
   407f6:	e0 2d       	mov	r30, r0
   407f8:	84 81       	ldd	r24, Z+4	; 0x04
   407fa:	88 23       	and	r24, r24
   407fc:	71 f0       	breq	.+28     	; 0x4081a <udc_reset+0x3a>
   407fe:	c0 e0       	ldi	r28, 0x00	; 0
   40800:	8c 2f       	mov	r24, r28
   40802:	aa df       	rcall	.-172    	; 0x40758 <udc_iface_disable>
   40804:	cf 5f       	subi	r28, 0xFF	; 255
   40806:	e0 91 f7 28 	lds	r30, 0x28F7
   4080a:	f0 91 f8 28 	lds	r31, 0x28F8
   4080e:	01 90       	ld	r0, Z+
   40810:	f0 81       	ld	r31, Z
   40812:	e0 2d       	mov	r30, r0
   40814:	84 81       	ldd	r24, Z+4	; 0x04
   40816:	c8 17       	cp	r28, r24
   40818:	98 f3       	brcs	.-26     	; 0x40800 <udc_reset+0x20>
   4081a:	10 92 f9 28 	sts	0x28F9, r1
   4081e:	81 e0       	ldi	r24, 0x01	; 1
   40820:	90 e0       	ldi	r25, 0x00	; 0
   40822:	80 93 fa 28 	sts	0x28FA, r24
   40826:	90 93 fb 28 	sts	0x28FB, r25
   4082a:	cf 91       	pop	r28
   4082c:	08 95       	ret

0004082e <udc_sof_notify>:
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}

void udc_sof_notify(void)
{
   4082e:	cf 93       	push	r28
	uint8_t iface_num;

	if (udc_num_configuration) {
   40830:	80 91 f9 28 	lds	r24, 0x28F9
   40834:	88 23       	and	r24, r24
   40836:	41 f1       	breq	.+80     	; 0x40888 <udc_sof_notify+0x5a>
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   40838:	e0 91 f7 28 	lds	r30, 0x28F7
   4083c:	f0 91 f8 28 	lds	r31, 0x28F8
   40840:	a0 81       	ld	r26, Z
   40842:	b1 81       	ldd	r27, Z+1	; 0x01
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
   40844:	14 96       	adiw	r26, 0x04	; 4
   40846:	8c 91       	ld	r24, X
   40848:	88 23       	and	r24, r24
   4084a:	f1 f0       	breq	.+60     	; 0x40888 <udc_sof_notify+0x5a>
   4084c:	c0 e0       	ldi	r28, 0x00	; 0
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
   4084e:	8c 2f       	mov	r24, r28
   40850:	90 e0       	ldi	r25, 0x00	; 0
   40852:	88 0f       	add	r24, r24
   40854:	99 1f       	adc	r25, r25
   40856:	02 80       	ldd	r0, Z+2	; 0x02
   40858:	f3 81       	ldd	r31, Z+3	; 0x03
   4085a:	e0 2d       	mov	r30, r0
   4085c:	e8 0f       	add	r30, r24
   4085e:	f9 1f       	adc	r31, r25
   40860:	01 90       	ld	r0, Z+
   40862:	f0 81       	ld	r31, Z
   40864:	e0 2d       	mov	r30, r0
   40866:	00 84       	ldd	r0, Z+8	; 0x08
   40868:	f1 85       	ldd	r31, Z+9	; 0x09
   4086a:	e0 2d       	mov	r30, r0
   4086c:	30 97       	sbiw	r30, 0x00	; 0
   4086e:	09 f0       	breq	.+2      	; 0x40872 <udc_sof_notify+0x44>
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
   40870:	19 95       	eicall
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
   40872:	cf 5f       	subi	r28, 0xFF	; 255
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   40874:	e0 91 f7 28 	lds	r30, 0x28F7
   40878:	f0 91 f8 28 	lds	r31, 0x28F8
   4087c:	a0 81       	ld	r26, Z
   4087e:	b1 81       	ldd	r27, Z+1	; 0x01
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
   40880:	14 96       	adiw	r26, 0x04	; 4
   40882:	8c 91       	ld	r24, X
   40884:	c8 17       	cp	r28, r24
   40886:	18 f3       	brcs	.-58     	; 0x4084e <udc_sof_notify+0x20>
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
			}
		}
	}
}
   40888:	cf 91       	pop	r28
   4088a:	08 95       	ret

0004088c <udc_process_setup>:
 * sent to a specific application callback.
 *
 * \return true if the request is supported, else the request is stalled by UDD
 */
bool udc_process_setup(void)
{
   4088c:	ef 92       	push	r14
   4088e:	ff 92       	push	r15
   40890:	0f 93       	push	r16
   40892:	1f 93       	push	r17
   40894:	cf 93       	push	r28
   40896:	df 93       	push	r29
	VPORT1.OUT = 0x02;		// Green LED
   40898:	82 e0       	ldi	r24, 0x02	; 2
   4089a:	85 bb       	out	0x15, r24	; 21
	// By default no data (receive/send) and no callbacks registered
	udd_g_ctrlreq.payload_size = 0;
   4089c:	10 92 6d 29 	sts	0x296D, r1
   408a0:	10 92 6e 29 	sts	0x296E, r1
	udd_g_ctrlreq.callback = NULL;
   408a4:	10 92 6f 29 	sts	0x296F, r1
   408a8:	10 92 70 29 	sts	0x2970, r1
	udd_g_ctrlreq.over_under_run = NULL;
   408ac:	10 92 71 29 	sts	0x2971, r1
   408b0:	10 92 72 29 	sts	0x2972, r1

	if (Udd_setup_is_in()) {
   408b4:	20 91 63 29 	lds	r18, 0x2963
   408b8:	22 23       	and	r18, r18
   408ba:	0c f0       	brlt	.+2      	; 0x408be <udc_process_setup+0x32>
   408bc:	45 c2       	rjmp	.+1162   	; 0x40d48 <udc_process_setup+0x4bc>
		if (udd_g_ctrlreq.req.wLength == 0) {
   408be:	80 91 69 29 	lds	r24, 0x2969
   408c2:	90 91 6a 29 	lds	r25, 0x296A
   408c6:	00 97       	sbiw	r24, 0x00	; 0
   408c8:	09 f0       	breq	.+2      	; 0x408cc <udc_process_setup+0x40>
   408ca:	43 c2       	rjmp	.+1158   	; 0x40d52 <udc_process_setup+0x4c6>
   408cc:	39 c2       	rjmp	.+1138   	; 0x40d40 <udc_process_setup+0x4b4>
		// GET Standard Requests
		if (udd_g_ctrlreq.req.wLength == 0) {
			return false; // Error for USB host
		}

		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
   408ce:	2f 71       	andi	r18, 0x1F	; 31
   408d0:	09 f0       	breq	.+2      	; 0x408d4 <udc_process_setup+0x48>
   408d2:	bb c0       	rjmp	.+374    	; 0x40a4a <udc_process_setup+0x1be>
			// Standard Get Device request
			switch (udd_g_ctrlreq.req.bRequest) {
   408d4:	30 91 64 29 	lds	r19, 0x2964
   408d8:	36 30       	cpi	r19, 0x06	; 6
   408da:	81 f0       	breq	.+32     	; 0x408fc <udc_process_setup+0x70>
   408dc:	38 30       	cpi	r19, 0x08	; 8
   408de:	09 f4       	brne	.+2      	; 0x408e2 <udc_process_setup+0x56>
   408e0:	a9 c0       	rjmp	.+338    	; 0x40a34 <udc_process_setup+0x1a8>
   408e2:	31 11       	cpse	r19, r1
   408e4:	b2 c0       	rjmp	.+356    	; 0x40a4a <udc_process_setup+0x1be>
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_status(void)
{
	if (udd_g_ctrlreq.req.wLength != sizeof(udc_device_status)) {
   408e6:	02 97       	sbiw	r24, 0x02	; 2
   408e8:	39 f4       	brne	.+14     	; 0x408f8 <udc_process_setup+0x6c>
		return false;
	}

	udd_set_setup_payload( (uint8_t *) & udc_device_status,
   408ea:	62 e0       	ldi	r22, 0x02	; 2
   408ec:	70 e0       	ldi	r23, 0x00	; 0
   408ee:	8a ef       	ldi	r24, 0xFA	; 250
   408f0:	98 e2       	ldi	r25, 0x28	; 40
   408f2:	d7 d3       	rcall	.+1966   	; 0x410a2 <udd_set_setup_payload>
			sizeof(udc_device_status));
	return true;
   408f4:	01 e0       	ldi	r16, 0x01	; 1
   408f6:	a7 c1       	rjmp	.+846    	; 0x40c46 <udc_process_setup+0x3ba>
 * \return true if success
 */
static bool udc_req_std_dev_get_status(void)
{
	if (udd_g_ctrlreq.req.wLength != sizeof(udc_device_status)) {
		return false;
   408f8:	00 e0       	ldi	r16, 0x00	; 0
   408fa:	a5 c1       	rjmp	.+842    	; 0x40c46 <udc_process_setup+0x3ba>
 */
static bool udc_req_std_dev_get_descriptor(void)
{
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
   408fc:	20 91 65 29 	lds	r18, 0x2965
   40900:	30 91 66 29 	lds	r19, 0x2966

	// Check descriptor ID
	switch ((uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
   40904:	83 2f       	mov	r24, r19
   40906:	99 27       	eor	r25, r25
   40908:	82 30       	cpi	r24, 0x02	; 2
   4090a:	91 05       	cpc	r25, r1
   4090c:	99 f0       	breq	.+38     	; 0x40934 <udc_process_setup+0xa8>
   4090e:	1c f4       	brge	.+6      	; 0x40916 <udc_process_setup+0x8a>
   40910:	01 97       	sbiw	r24, 0x01	; 1
   40912:	39 f0       	breq	.+14     	; 0x40922 <udc_process_setup+0x96>
   40914:	85 c0       	rjmp	.+266    	; 0x40a20 <udc_process_setup+0x194>
   40916:	83 30       	cpi	r24, 0x03	; 3
   40918:	91 05       	cpc	r25, r1
   4091a:	d9 f1       	breq	.+118    	; 0x40992 <udc_process_setup+0x106>
   4091c:	0f 97       	sbiw	r24, 0x0f	; 15
   4091e:	59 f1       	breq	.+86     	; 0x40976 <udc_process_setup+0xea>
   40920:	7f c0       	rjmp	.+254    	; 0x40a20 <udc_process_setup+0x194>
		} else
#endif
		{
			udd_set_setup_payload(
				(uint8_t *) udc_config.confdev_lsfs,
				udc_config.confdev_lsfs->bLength);
   40922:	80 91 20 20 	lds	r24, 0x2020
   40926:	90 91 21 20 	lds	r25, 0x2021
				(uint8_t *) udc_config.confdev_hs,
				udc_config.confdev_hs->bLength);
		} else
#endif
		{
			udd_set_setup_payload(
   4092a:	dc 01       	movw	r26, r24
   4092c:	6c 91       	ld	r22, X
   4092e:	70 e0       	ldi	r23, 0x00	; 0
   40930:	b8 d3       	rcall	.+1904   	; 0x410a2 <udd_set_setup_payload>
   40932:	65 c0       	rjmp	.+202    	; 0x409fe <udc_process_setup+0x172>
				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
		} else
#endif
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
   40934:	e0 91 20 20 	lds	r30, 0x2020
   40938:	f0 91 21 20 	lds	r31, 0x2021
   4093c:	81 89       	ldd	r24, Z+17	; 0x11
   4093e:	28 17       	cp	r18, r24
   40940:	08 f0       	brcs	.+2      	; 0x40944 <udc_process_setup+0xb8>
   40942:	70 c0       	rjmp	.+224    	; 0x40a24 <udc_process_setup+0x198>
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
   40944:	c9 01       	movw	r24, r18
   40946:	99 27       	eor	r25, r25
   40948:	88 0f       	add	r24, r24
   4094a:	99 1f       	adc	r25, r25
   4094c:	88 0f       	add	r24, r24
   4094e:	99 1f       	adc	r25, r25
   40950:	e0 91 22 20 	lds	r30, 0x2022
   40954:	f0 91 23 20 	lds	r31, 0x2023
   40958:	e8 0f       	add	r30, r24
   4095a:	f9 1f       	adc	r31, r25
   4095c:	80 81       	ld	r24, Z
   4095e:	91 81       	ldd	r25, Z+1	; 0x01
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
   40960:	fc 01       	movw	r30, r24
   40962:	62 81       	ldd	r22, Z+2	; 0x02
   40964:	73 81       	ldd	r23, Z+3	; 0x03
   40966:	9d d3       	rcall	.+1850   	; 0x410a2 <udd_set_setup_payload>
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
		}
		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
   40968:	e0 91 6b 29 	lds	r30, 0x296B
   4096c:	f0 91 6c 29 	lds	r31, 0x296C
   40970:	82 e0       	ldi	r24, 0x02	; 2
   40972:	81 83       	std	Z+1, r24	; 0x01
   40974:	44 c0       	rjmp	.+136    	; 0x409fe <udc_process_setup+0x172>
		break;
#endif

	case USB_DT_BOS:
		// Device BOS descriptor requested
		if (udc_config.conf_bos == NULL) {
   40976:	80 91 24 20 	lds	r24, 0x2024
   4097a:	90 91 25 20 	lds	r25, 0x2025
   4097e:	00 97       	sbiw	r24, 0x00	; 0
   40980:	09 f4       	brne	.+2      	; 0x40984 <udc_process_setup+0xf8>
   40982:	52 c0       	rjmp	.+164    	; 0x40a28 <udc_process_setup+0x19c>
			return false;
		}
		udd_set_setup_payload( (uint8_t *) udc_config.conf_bos,
   40984:	dc 01       	movw	r26, r24
   40986:	12 96       	adiw	r26, 0x02	; 2
   40988:	6d 91       	ld	r22, X+
   4098a:	7c 91       	ld	r23, X
   4098c:	13 97       	sbiw	r26, 0x03	; 3
   4098e:	89 d3       	rcall	.+1810   	; 0x410a2 <udd_set_setup_payload>
   40990:	36 c0       	rjmp	.+108    	; 0x409fe <udc_process_setup+0x172>
	uint8_t i;
	const uint8_t *str;
	uint8_t str_length = 0;

	// Link payload pointer to the string corresponding at request
	switch (udd_g_ctrlreq.req.wValue & 0xff) {
   40992:	33 27       	eor	r19, r19
   40994:	21 15       	cp	r18, r1
   40996:	31 05       	cpc	r19, r1
   40998:	21 f0       	breq	.+8      	; 0x409a2 <udc_process_setup+0x116>
   4099a:	21 30       	cpi	r18, 0x01	; 1
   4099c:	31 05       	cpc	r19, r1
   4099e:	39 f0       	breq	.+14     	; 0x409ae <udc_process_setup+0x122>
   409a0:	45 c0       	rjmp	.+138    	; 0x40a2c <udc_process_setup+0x1a0>
	case 0:
		udd_set_setup_payload((uint8_t *) &udc_string_desc_languageid,
   409a2:	64 e0       	ldi	r22, 0x04	; 4
   409a4:	70 e0       	ldi	r23, 0x00	; 0
   409a6:	8c e1       	ldi	r24, 0x1C	; 28
   409a8:	90 e2       	ldi	r25, 0x20	; 32
   409aa:	7b d3       	rcall	.+1782   	; 0x410a2 <udd_set_setup_payload>
   409ac:	28 c0       	rjmp	.+80     	; 0x409fe <udc_process_setup+0x172>
		return false;
	}

	if (str_length) {
		for(i = 0; i < str_length; i++) {
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
   409ae:	e6 e1       	ldi	r30, 0x16	; 22
   409b0:	f0 e2       	ldi	r31, 0x20	; 32
   409b2:	80 81       	ld	r24, Z
   409b4:	90 e0       	ldi	r25, 0x00	; 0
   409b6:	80 93 0c 20 	sts	0x200C, r24
   409ba:	90 93 0d 20 	sts	0x200D, r25
   409be:	81 81       	ldd	r24, Z+1	; 0x01
   409c0:	90 e0       	ldi	r25, 0x00	; 0
   409c2:	80 93 0e 20 	sts	0x200E, r24
   409c6:	90 93 0f 20 	sts	0x200F, r25
   409ca:	82 81       	ldd	r24, Z+2	; 0x02
   409cc:	90 e0       	ldi	r25, 0x00	; 0
   409ce:	80 93 10 20 	sts	0x2010, r24
   409d2:	90 93 11 20 	sts	0x2011, r25
   409d6:	83 81       	ldd	r24, Z+3	; 0x03
   409d8:	90 e0       	ldi	r25, 0x00	; 0
   409da:	80 93 12 20 	sts	0x2012, r24
   409de:	90 93 13 20 	sts	0x2013, r25
   409e2:	84 81       	ldd	r24, Z+4	; 0x04
   409e4:	90 e0       	ldi	r25, 0x00	; 0
   409e6:	80 93 14 20 	sts	0x2014, r24
   409ea:	90 93 15 20 	sts	0x2015, r25
		}

		udc_string_desc.header.bLength = 2 + (str_length) * 2;
   409ee:	8c e0       	ldi	r24, 0x0C	; 12
   409f0:	80 93 0a 20 	sts	0x200A, r24
		udd_set_setup_payload(
   409f4:	6c e0       	ldi	r22, 0x0C	; 12
   409f6:	70 e0       	ldi	r23, 0x00	; 0
   409f8:	8a e0       	ldi	r24, 0x0A	; 10
   409fa:	90 e2       	ldi	r25, 0x20	; 32
   409fc:	52 d3       	rcall	.+1700   	; 0x410a2 <udd_set_setup_payload>
	default:
		// Unknown descriptor requested
		return false;
	}
	// if the descriptor is larger than length requested, then reduce it
	if (udd_g_ctrlreq.req.wLength < udd_g_ctrlreq.payload_size) {
   409fe:	80 91 69 29 	lds	r24, 0x2969
   40a02:	90 91 6a 29 	lds	r25, 0x296A
   40a06:	20 91 6d 29 	lds	r18, 0x296D
   40a0a:	30 91 6e 29 	lds	r19, 0x296E
   40a0e:	82 17       	cp	r24, r18
   40a10:	93 07       	cpc	r25, r19
   40a12:	70 f4       	brcc	.+28     	; 0x40a30 <udc_process_setup+0x1a4>
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
   40a14:	80 93 6d 29 	sts	0x296D, r24
   40a18:	90 93 6e 29 	sts	0x296E, r25
	}
	return true;
   40a1c:	01 e0       	ldi	r16, 0x01	; 1
   40a1e:	13 c1       	rjmp	.+550    	; 0x40c46 <udc_process_setup+0x3ba>
		}
		break;

	default:
		// Unknown descriptor requested
		return false;
   40a20:	00 e0       	ldi	r16, 0x00	; 0
   40a22:	11 c1       	rjmp	.+546    	; 0x40c46 <udc_process_setup+0x3ba>
#endif
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
					bNumConfigurations) {
				return false;
   40a24:	00 e0       	ldi	r16, 0x00	; 0
   40a26:	0f c1       	rjmp	.+542    	; 0x40c46 <udc_process_setup+0x3ba>
#endif

	case USB_DT_BOS:
		// Device BOS descriptor requested
		if (udc_config.conf_bos == NULL) {
			return false;
   40a28:	00 e0       	ldi	r16, 0x00	; 0
   40a2a:	0d c1       	rjmp	.+538    	; 0x40c46 <udc_process_setup+0x3ba>
		break;

	case USB_DT_STRING:
		// String descriptor requested
		if (!udc_req_std_dev_get_str_desc()) {
			return false;
   40a2c:	00 e0       	ldi	r16, 0x00	; 0
   40a2e:	0b c1       	rjmp	.+534    	; 0x40c46 <udc_process_setup+0x3ba>
	}
	// if the descriptor is larger than length requested, then reduce it
	if (udd_g_ctrlreq.req.wLength < udd_g_ctrlreq.payload_size) {
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
	}
	return true;
   40a30:	01 e0       	ldi	r16, 0x01	; 1
   40a32:	09 c1       	rjmp	.+530    	; 0x40c46 <udc_process_setup+0x3ba>
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_configuration(void)
{
	if (udd_g_ctrlreq.req.wLength != 1) {
   40a34:	01 97       	sbiw	r24, 0x01	; 1
   40a36:	39 f4       	brne	.+14     	; 0x40a46 <udc_process_setup+0x1ba>
		return false;
	}

	udd_set_setup_payload(&udc_num_configuration,1);
   40a38:	61 e0       	ldi	r22, 0x01	; 1
   40a3a:	70 e0       	ldi	r23, 0x00	; 0
   40a3c:	89 ef       	ldi	r24, 0xF9	; 249
   40a3e:	98 e2       	ldi	r25, 0x28	; 40
   40a40:	30 d3       	rcall	.+1632   	; 0x410a2 <udd_set_setup_payload>
	return true;
   40a42:	01 e0       	ldi	r16, 0x01	; 1
   40a44:	00 c1       	rjmp	.+512    	; 0x40c46 <udc_process_setup+0x3ba>
 * \return true if success
 */
static bool udc_req_std_dev_get_configuration(void)
{
	if (udd_g_ctrlreq.req.wLength != 1) {
		return false;
   40a46:	00 e0       	ldi	r16, 0x00	; 0
   40a48:	fe c0       	rjmp	.+508    	; 0x40c46 <udc_process_setup+0x3ba>
			default:
				break;
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
   40a4a:	21 30       	cpi	r18, 0x01	; 1
   40a4c:	09 f0       	breq	.+2      	; 0x40a50 <udc_process_setup+0x1c4>
   40a4e:	3a c1       	rjmp	.+628    	; 0x40cc4 <udc_process_setup+0x438>
			// Standard Get Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
   40a50:	20 91 64 29 	lds	r18, 0x2964
   40a54:	2a 30       	cpi	r18, 0x0A	; 10
   40a56:	09 f0       	breq	.+2      	; 0x40a5a <udc_process_setup+0x1ce>
   40a58:	f1 c0       	rjmp	.+482    	; 0x40c3c <udc_process_setup+0x3b0>
{
	static uint8_t udc_iface_setting;
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (udd_g_ctrlreq.req.wLength != 1) {
   40a5a:	01 97       	sbiw	r24, 0x01	; 1
   40a5c:	99 f5       	brne	.+102    	; 0x40ac4 <udc_process_setup+0x238>
		return false; // Error in request
	}
	if (!udc_num_configuration) {
   40a5e:	80 91 f9 28 	lds	r24, 0x28F9
   40a62:	88 23       	and	r24, r24
   40a64:	89 f1       	breq	.+98     	; 0x40ac8 <udc_process_setup+0x23c>
		return false; // The device is not is configured state yet
	}

	// Check the interface number included in the request
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
   40a66:	c0 91 67 29 	lds	r28, 0x2967
   40a6a:	d0 91 68 29 	lds	r29, 0x2968
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
   40a6e:	e0 90 f7 28 	lds	r14, 0x28F7
   40a72:	f0 90 f8 28 	lds	r15, 0x28F8
   40a76:	d7 01       	movw	r26, r14
   40a78:	ed 91       	ld	r30, X+
   40a7a:	fc 91       	ld	r31, X
   40a7c:	84 81       	ldd	r24, Z+4	; 0x04
   40a7e:	c8 17       	cp	r28, r24
   40a80:	28 f5       	brcc	.+74     	; 0x40acc <udc_process_setup+0x240>
		return false;
	}

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
   40a82:	60 e0       	ldi	r22, 0x00	; 0
   40a84:	8c 2f       	mov	r24, r28
   40a86:	2e de       	rcall	.-932    	; 0x406e4 <udc_update_iface_desc>
   40a88:	08 2f       	mov	r16, r24
   40a8a:	88 23       	and	r24, r24
   40a8c:	09 f4       	brne	.+2      	; 0x40a90 <udc_process_setup+0x204>
   40a8e:	db c0       	rjmp	.+438    	; 0x40c46 <udc_process_setup+0x3ba>
		return false;
	}
	// Get alternate setting from UDI
	udi_api = udc_ptr_conf->udi_apis[iface_num];
   40a90:	ce 01       	movw	r24, r28
   40a92:	99 27       	eor	r25, r25
   40a94:	88 0f       	add	r24, r24
   40a96:	99 1f       	adc	r25, r25
   40a98:	d7 01       	movw	r26, r14
   40a9a:	12 96       	adiw	r26, 0x02	; 2
   40a9c:	ed 91       	ld	r30, X+
   40a9e:	fc 91       	ld	r31, X
   40aa0:	13 97       	sbiw	r26, 0x03	; 3
   40aa2:	e8 0f       	add	r30, r24
   40aa4:	f9 1f       	adc	r31, r25
	udc_iface_setting = udi_api->getsetting();
   40aa6:	01 90       	ld	r0, Z+
   40aa8:	f0 81       	ld	r31, Z
   40aaa:	e0 2d       	mov	r30, r0
   40aac:	06 80       	ldd	r0, Z+6	; 0x06
   40aae:	f7 81       	ldd	r31, Z+7	; 0x07
   40ab0:	e0 2d       	mov	r30, r0
   40ab2:	19 95       	eicall
   40ab4:	80 93 f4 28 	sts	0x28F4, r24

	// Link value to payload pointer of request
	udd_set_setup_payload(&udc_iface_setting,1);
   40ab8:	61 e0       	ldi	r22, 0x01	; 1
   40aba:	70 e0       	ldi	r23, 0x00	; 0
   40abc:	84 ef       	ldi	r24, 0xF4	; 244
   40abe:	98 e2       	ldi	r25, 0x28	; 40
   40ac0:	f0 d2       	rcall	.+1504   	; 0x410a2 <udd_set_setup_payload>
   40ac2:	c1 c0       	rjmp	.+386    	; 0x40c46 <udc_process_setup+0x3ba>
	static uint8_t udc_iface_setting;
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (udd_g_ctrlreq.req.wLength != 1) {
		return false; // Error in request
   40ac4:	00 e0       	ldi	r16, 0x00	; 0
   40ac6:	bf c0       	rjmp	.+382    	; 0x40c46 <udc_process_setup+0x3ba>
	}
	if (!udc_num_configuration) {
		return false; // The device is not is configured state yet
   40ac8:	00 e0       	ldi	r16, 0x00	; 0
   40aca:	bd c0       	rjmp	.+378    	; 0x40c46 <udc_process_setup+0x3ba>
	}

	// Check the interface number included in the request
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
		return false;
   40acc:	00 e0       	ldi	r16, 0x00	; 0
   40ace:	bb c0       	rjmp	.+374    	; 0x40c46 <udc_process_setup+0x3ba>
			}
		}
#endif
	} else {
		// SET Standard Requests
		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
   40ad0:	2f 71       	andi	r18, 0x1F	; 31
   40ad2:	09 f0       	breq	.+2      	; 0x40ad6 <udc_process_setup+0x24a>
   40ad4:	90 c0       	rjmp	.+288    	; 0x40bf6 <udc_process_setup+0x36a>
			// Standard Set Device request
			switch (udd_g_ctrlreq.req.bRequest) {
   40ad6:	80 91 64 29 	lds	r24, 0x2964
   40ada:	83 30       	cpi	r24, 0x03	; 3
   40adc:	09 f4       	brne	.+2      	; 0x40ae0 <udc_process_setup+0x254>
   40ade:	b0 c0       	rjmp	.+352    	; 0x40c40 <udc_process_setup+0x3b4>
   40ae0:	18 f4       	brcc	.+6      	; 0x40ae8 <udc_process_setup+0x25c>
   40ae2:	81 30       	cpi	r24, 0x01	; 1
   40ae4:	b1 f0       	breq	.+44     	; 0x40b12 <udc_process_setup+0x286>
   40ae6:	87 c0       	rjmp	.+270    	; 0x40bf6 <udc_process_setup+0x36a>
   40ae8:	85 30       	cpi	r24, 0x05	; 5
   40aea:	19 f0       	breq	.+6      	; 0x40af2 <udc_process_setup+0x266>
   40aec:	89 30       	cpi	r24, 0x09	; 9
   40aee:	61 f1       	breq	.+88     	; 0x40b48 <udc_process_setup+0x2bc>
   40af0:	82 c0       	rjmp	.+260    	; 0x40bf6 <udc_process_setup+0x36a>
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_address(void)
{
	if (udd_g_ctrlreq.req.wLength) {
   40af2:	80 91 69 29 	lds	r24, 0x2969
   40af6:	90 91 6a 29 	lds	r25, 0x296A
   40afa:	89 2b       	or	r24, r25
   40afc:	41 f4       	brne	.+16     	; 0x40b0e <udc_process_setup+0x282>
		return false;
	}

	// The address must be changed at the end of setup request after the handshake
	// then we use a callback to change address
	udd_g_ctrlreq.callback = udc_valid_address;
   40afe:	89 ee       	ldi	r24, 0xE9	; 233
   40b00:	93 e0       	ldi	r25, 0x03	; 3
   40b02:	80 93 6f 29 	sts	0x296F, r24
   40b06:	90 93 70 29 	sts	0x2970, r25
	return true;
   40b0a:	01 e0       	ldi	r16, 0x01	; 1
   40b0c:	9c c0       	rjmp	.+312    	; 0x40c46 <udc_process_setup+0x3ba>
 * \return true if success
 */
static bool udc_req_std_dev_set_address(void)
{
	if (udd_g_ctrlreq.req.wLength) {
		return false;
   40b0e:	00 e0       	ldi	r16, 0x00	; 0
   40b10:	9a c0       	rjmp	.+308    	; 0x40c46 <udc_process_setup+0x3ba>
 *
 * \return true if success
 */
static bool udc_req_std_dev_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength) {
   40b12:	80 91 69 29 	lds	r24, 0x2969
   40b16:	90 91 6a 29 	lds	r25, 0x296A
   40b1a:	89 2b       	or	r24, r25
   40b1c:	89 f4       	brne	.+34     	; 0x40b40 <udc_process_setup+0x2b4>
		return false;
	}

	if (udd_g_ctrlreq.req.wValue == USB_DEV_FEATURE_REMOTE_WAKEUP) {
   40b1e:	80 91 65 29 	lds	r24, 0x2965
   40b22:	90 91 66 29 	lds	r25, 0x2966
   40b26:	01 97       	sbiw	r24, 0x01	; 1
   40b28:	69 f4       	brne	.+26     	; 0x40b44 <udc_process_setup+0x2b8>
		udc_device_status &= CPU_TO_LE16(~(uint32_t)USB_DEV_STATUS_REMOTEWAKEUP);
   40b2a:	80 91 fa 28 	lds	r24, 0x28FA
   40b2e:	90 91 fb 28 	lds	r25, 0x28FB
   40b32:	8d 7f       	andi	r24, 0xFD	; 253
   40b34:	80 93 fa 28 	sts	0x28FA, r24
   40b38:	90 93 fb 28 	sts	0x28FB, r25
#if (USB_CONFIG_ATTR_REMOTE_WAKEUP \
	== (USB_DEVICE_ATTR & USB_CONFIG_ATTR_REMOTE_WAKEUP))
		UDC_REMOTEWAKEUP_DISABLE();
#endif
		return true;
   40b3c:	01 e0       	ldi	r16, 0x01	; 1
   40b3e:	83 c0       	rjmp	.+262    	; 0x40c46 <udc_process_setup+0x3ba>
 * \return true if success
 */
static bool udc_req_std_dev_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength) {
		return false;
   40b40:	00 e0       	ldi	r16, 0x00	; 0
   40b42:	81 c0       	rjmp	.+258    	; 0x40c46 <udc_process_setup+0x3ba>
	== (USB_DEVICE_ATTR & USB_CONFIG_ATTR_REMOTE_WAKEUP))
		UDC_REMOTEWAKEUP_DISABLE();
#endif
		return true;
	}
	return false;
   40b44:	00 e0       	ldi	r16, 0x00	; 0
   40b46:	7f c0       	rjmp	.+254    	; 0x40c46 <udc_process_setup+0x3ba>
static bool udc_req_std_dev_set_configuration(void)
{
	uint8_t iface_num;

	// Check request length
	if (udd_g_ctrlreq.req.wLength) {
   40b48:	80 91 69 29 	lds	r24, 0x2969
   40b4c:	90 91 6a 29 	lds	r25, 0x296A
   40b50:	89 2b       	or	r24, r25
   40b52:	09 f0       	breq	.+2      	; 0x40b56 <udc_process_setup+0x2ca>
   40b54:	46 c0       	rjmp	.+140    	; 0x40be2 <udc_process_setup+0x356>
		return false;
	}
	// Authorize configuration only if the address is valid
	if (!udd_getaddress()) {
   40b56:	a2 d2       	rcall	.+1348   	; 0x4109c <udd_getaddress>
   40b58:	88 23       	and	r24, r24
   40b5a:	09 f4       	brne	.+2      	; 0x40b5e <udc_process_setup+0x2d2>
   40b5c:	44 c0       	rjmp	.+136    	; 0x40be6 <udc_process_setup+0x35a>
		}
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
   40b5e:	20 91 65 29 	lds	r18, 0x2965
   40b62:	30 91 66 29 	lds	r19, 0x2966
   40b66:	33 27       	eor	r19, r19
				udc_config.confdev_lsfs->bNumConfigurations) {
   40b68:	e0 91 20 20 	lds	r30, 0x2020
   40b6c:	f0 91 21 20 	lds	r31, 0x2021
		}
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
   40b70:	81 89       	ldd	r24, Z+17	; 0x11
   40b72:	90 e0       	ldi	r25, 0x00	; 0
   40b74:	82 17       	cp	r24, r18
   40b76:	93 07       	cpc	r25, r19
   40b78:	c0 f1       	brcs	.+112    	; 0x40bea <udc_process_setup+0x35e>
			return false;
		}
	}

	// Reset current configuration
	udc_reset();
   40b7a:	32 de       	rcall	.-924    	; 0x407e0 <udc_reset>

	// Enable new configuration
	udc_num_configuration = udd_g_ctrlreq.req.wValue & 0xFF;
   40b7c:	80 91 65 29 	lds	r24, 0x2965
   40b80:	90 91 66 29 	lds	r25, 0x2966
   40b84:	80 93 f9 28 	sts	0x28F9, r24
	if (udc_num_configuration == 0) {
   40b88:	88 23       	and	r24, r24
   40b8a:	89 f1       	breq	.+98     	; 0x40bee <udc_process_setup+0x362>
		udc_ptr_conf = &udc_config.conf_hs[udc_num_configuration - 1];
	} else
#endif
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
   40b8c:	99 27       	eor	r25, r25
   40b8e:	81 50       	subi	r24, 0x01	; 1
   40b90:	90 4c       	sbci	r25, 0xC0	; 192
   40b92:	88 0f       	add	r24, r24
   40b94:	99 1f       	adc	r25, r25
   40b96:	88 0f       	add	r24, r24
   40b98:	99 1f       	adc	r25, r25
   40b9a:	e0 91 22 20 	lds	r30, 0x2022
   40b9e:	f0 91 23 20 	lds	r31, 0x2023
   40ba2:	e8 0f       	add	r30, r24
   40ba4:	f9 1f       	adc	r31, r25
   40ba6:	e0 93 f7 28 	sts	0x28F7, r30
   40baa:	f0 93 f8 28 	sts	0x28F8, r31
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   40bae:	01 90       	ld	r0, Z+
   40bb0:	f0 81       	ld	r31, Z
   40bb2:	e0 2d       	mov	r30, r0
   40bb4:	84 81       	ldd	r24, Z+4	; 0x04
   40bb6:	88 23       	and	r24, r24
   40bb8:	e1 f0       	breq	.+56     	; 0x40bf2 <udc_process_setup+0x366>
   40bba:	c0 e0       	ldi	r28, 0x00	; 0
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0)) {
   40bbc:	60 e0       	ldi	r22, 0x00	; 0
   40bbe:	8c 2f       	mov	r24, r28
   40bc0:	ec dd       	rcall	.-1064   	; 0x4079a <udc_iface_enable>
   40bc2:	08 2f       	mov	r16, r24
   40bc4:	88 23       	and	r24, r24
   40bc6:	09 f4       	brne	.+2      	; 0x40bca <udc_process_setup+0x33e>
   40bc8:	3e c0       	rjmp	.+124    	; 0x40c46 <udc_process_setup+0x3ba>
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
			iface_num++) {
   40bca:	cf 5f       	subi	r28, 0xFF	; 255
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   40bcc:	e0 91 f7 28 	lds	r30, 0x28F7
   40bd0:	f0 91 f8 28 	lds	r31, 0x28F8
   40bd4:	01 90       	ld	r0, Z+
   40bd6:	f0 81       	ld	r31, Z
   40bd8:	e0 2d       	mov	r30, r0
   40bda:	84 81       	ldd	r24, Z+4	; 0x04
   40bdc:	c8 17       	cp	r28, r24
   40bde:	70 f3       	brcs	.-36     	; 0x40bbc <udc_process_setup+0x330>
   40be0:	32 c0       	rjmp	.+100    	; 0x40c46 <udc_process_setup+0x3ba>
{
	uint8_t iface_num;

	// Check request length
	if (udd_g_ctrlreq.req.wLength) {
		return false;
   40be2:	00 e0       	ldi	r16, 0x00	; 0
   40be4:	30 c0       	rjmp	.+96     	; 0x40c46 <udc_process_setup+0x3ba>
	}
	// Authorize configuration only if the address is valid
	if (!udd_getaddress()) {
		return false;
   40be6:	00 e0       	ldi	r16, 0x00	; 0
   40be8:	2e c0       	rjmp	.+92     	; 0x40c46 <udc_process_setup+0x3ba>
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
				udc_config.confdev_lsfs->bNumConfigurations) {
			return false;
   40bea:	00 e0       	ldi	r16, 0x00	; 0
   40bec:	2c c0       	rjmp	.+88     	; 0x40c46 <udc_process_setup+0x3ba>
	udc_reset();

	// Enable new configuration
	udc_num_configuration = udd_g_ctrlreq.req.wValue & 0xFF;
	if (udc_num_configuration == 0) {
		return true; // Default empty configuration requested
   40bee:	01 e0       	ldi	r16, 0x01	; 1
   40bf0:	2a c0       	rjmp	.+84     	; 0x40c46 <udc_process_setup+0x3ba>
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0)) {
			return false;
		}
	}
	return true;
   40bf2:	01 e0       	ldi	r16, 0x01	; 1
   40bf4:	28 c0       	rjmp	.+80     	; 0x40c46 <udc_process_setup+0x3ba>
			default:
				break;
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
   40bf6:	21 30       	cpi	r18, 0x01	; 1
   40bf8:	09 f0       	breq	.+2      	; 0x40bfc <udc_process_setup+0x370>
   40bfa:	64 c0       	rjmp	.+200    	; 0x40cc4 <udc_process_setup+0x438>
			// Standard Set Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
   40bfc:	80 91 64 29 	lds	r24, 0x2964
   40c00:	8b 30       	cpi	r24, 0x0B	; 11
   40c02:	01 f5       	brne	.+64     	; 0x40c44 <udc_process_setup+0x3b8>
 */
static bool udc_req_std_iface_set_setting(void)
{
	uint8_t iface_num, setting_num;

	if (udd_g_ctrlreq.req.wLength) {
   40c04:	80 91 69 29 	lds	r24, 0x2969
   40c08:	90 91 6a 29 	lds	r25, 0x296A
   40c0c:	89 2b       	or	r24, r25
   40c0e:	91 f4       	brne	.+36     	; 0x40c34 <udc_process_setup+0x3a8>
		return false; // Error in request
	}
	if (!udc_num_configuration) {
   40c10:	80 91 f9 28 	lds	r24, 0x28F9
   40c14:	88 23       	and	r24, r24
   40c16:	81 f0       	breq	.+32     	; 0x40c38 <udc_process_setup+0x3ac>
		return false; // The device is not is configured state yet
	}

	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
   40c18:	c0 91 67 29 	lds	r28, 0x2967
	setting_num = udd_g_ctrlreq.req.wValue & 0xFF;
   40c1c:	d0 91 65 29 	lds	r29, 0x2965

	// Disable current setting
	if (!udc_iface_disable(iface_num)) {
   40c20:	8c 2f       	mov	r24, r28
   40c22:	9a dd       	rcall	.-1228   	; 0x40758 <udc_iface_disable>
   40c24:	08 2f       	mov	r16, r24
   40c26:	88 23       	and	r24, r24
   40c28:	71 f0       	breq	.+28     	; 0x40c46 <udc_process_setup+0x3ba>
		return false;
	}

	// Enable new setting
	return udc_iface_enable(iface_num, setting_num);
   40c2a:	6d 2f       	mov	r22, r29
   40c2c:	8c 2f       	mov	r24, r28
   40c2e:	b5 dd       	rcall	.-1174   	; 0x4079a <udc_iface_enable>
   40c30:	08 2f       	mov	r16, r24
   40c32:	09 c0       	rjmp	.+18     	; 0x40c46 <udc_process_setup+0x3ba>
static bool udc_req_std_iface_set_setting(void)
{
	uint8_t iface_num, setting_num;

	if (udd_g_ctrlreq.req.wLength) {
		return false; // Error in request
   40c34:	00 e0       	ldi	r16, 0x00	; 0
   40c36:	07 c0       	rjmp	.+14     	; 0x40c46 <udc_process_setup+0x3ba>
	}
	if (!udc_num_configuration) {
		return false; // The device is not is configured state yet
   40c38:	00 e0       	ldi	r16, 0x00	; 0
   40c3a:	05 c0       	rjmp	.+10     	; 0x40c46 <udc_process_setup+0x3ba>
				break;
			}
		}
#endif
	}
	return false;
   40c3c:	00 e0       	ldi	r16, 0x00	; 0
   40c3e:	03 c0       	rjmp	.+6      	; 0x40c46 <udc_process_setup+0x3ba>
			case USB_REQ_SET_ADDRESS:
				return udc_req_std_dev_set_address();
			case USB_REQ_CLEAR_FEATURE:
				return udc_req_std_dev_clear_feature();
			case USB_REQ_SET_FEATURE:
				return udc_req_std_dev_set_feature();
   40c40:	00 e0       	ldi	r16, 0x00	; 0
   40c42:	01 c0       	rjmp	.+2      	; 0x40c46 <udc_process_setup+0x3ba>
				break;
			}
		}
#endif
	}
	return false;
   40c44:	00 e0       	ldi	r16, 0x00	; 0
		}
	}

	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
		if (udc_reqstd()) {
   40c46:	01 11       	cpse	r16, r1
   40c48:	89 c0       	rjmp	.+274    	; 0x40d5c <udc_process_setup+0x4d0>
			return true;
		}
	}

	// If interface request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
   40c4a:	80 91 63 29 	lds	r24, 0x2963
   40c4e:	8f 71       	andi	r24, 0x1F	; 31
   40c50:	81 30       	cpi	r24, 0x01	; 1
   40c52:	c1 f5       	brne	.+112    	; 0x40cc4 <udc_process_setup+0x438>
static bool udc_req_iface(void)
{
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
   40c54:	80 91 f9 28 	lds	r24, 0x28F9
   40c58:	88 23       	and	r24, r24
   40c5a:	a1 f1       	breq	.+104    	; 0x40cc4 <udc_process_setup+0x438>
		return false; // The device is not is configured state yet
	}
	// Check interface number
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
   40c5c:	c0 91 67 29 	lds	r28, 0x2967
   40c60:	d0 91 68 29 	lds	r29, 0x2968
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
   40c64:	00 91 f7 28 	lds	r16, 0x28F7
   40c68:	10 91 f8 28 	lds	r17, 0x28F8
   40c6c:	d8 01       	movw	r26, r16
   40c6e:	ed 91       	ld	r30, X+
   40c70:	fc 91       	ld	r31, X
   40c72:	84 81       	ldd	r24, Z+4	; 0x04
   40c74:	c8 17       	cp	r28, r24
   40c76:	30 f5       	brcc	.+76     	; 0x40cc4 <udc_process_setup+0x438>
	}

	//* To update udc_ptr_iface with the selected interface in request
	// Select first alternate setting of interface to update udc_ptr_iface
	// before calling udi_api->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
   40c78:	60 e0       	ldi	r22, 0x00	; 0
   40c7a:	8c 2f       	mov	r24, r28
   40c7c:	33 dd       	rcall	.-1434   	; 0x406e4 <udc_update_iface_desc>
   40c7e:	88 23       	and	r24, r24
   40c80:	09 f1       	breq	.+66     	; 0x40cc4 <udc_process_setup+0x438>
		return false;
	}
	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
   40c82:	ce 01       	movw	r24, r28
   40c84:	99 27       	eor	r25, r25
   40c86:	88 0f       	add	r24, r24
   40c88:	99 1f       	adc	r25, r25
   40c8a:	d8 01       	movw	r26, r16
   40c8c:	12 96       	adiw	r26, 0x02	; 2
   40c8e:	ed 91       	ld	r30, X+
   40c90:	fc 91       	ld	r31, X
   40c92:	13 97       	sbiw	r26, 0x03	; 3
   40c94:	e8 0f       	add	r30, r24
   40c96:	f9 1f       	adc	r31, r25
   40c98:	00 81       	ld	r16, Z
   40c9a:	11 81       	ldd	r17, Z+1	; 0x01
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
   40c9c:	d8 01       	movw	r26, r16
   40c9e:	16 96       	adiw	r26, 0x06	; 6
   40ca0:	ed 91       	ld	r30, X+
   40ca2:	fc 91       	ld	r31, X
   40ca4:	17 97       	sbiw	r26, 0x07	; 7
   40ca6:	19 95       	eicall
   40ca8:	68 2f       	mov	r22, r24
   40caa:	8c 2f       	mov	r24, r28
   40cac:	1b dd       	rcall	.-1482   	; 0x406e4 <udc_update_iface_desc>
   40cae:	88 23       	and	r24, r24
   40cb0:	49 f0       	breq	.+18     	; 0x40cc4 <udc_process_setup+0x438>
		return false;
	}

	// Send the SETUP request to the UDI corresponding to the interface number
	return udi_api->setup();
   40cb2:	d8 01       	movw	r26, r16
   40cb4:	14 96       	adiw	r26, 0x04	; 4
   40cb6:	ed 91       	ld	r30, X+
   40cb8:	fc 91       	ld	r31, X
   40cba:	15 97       	sbiw	r26, 0x05	; 5
   40cbc:	19 95       	eicall
   40cbe:	08 2f       	mov	r16, r24
		}
	}

	// If interface request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
		if (udc_req_iface()) {
   40cc0:	81 11       	cpse	r24, r1
   40cc2:	4c c0       	rjmp	.+152    	; 0x40d5c <udc_process_setup+0x4d0>
			return true;
		}
	}

	// If endpoint request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_ENDPOINT) {
   40cc4:	80 91 63 29 	lds	r24, 0x2963
   40cc8:	8f 71       	andi	r24, 0x1F	; 31
   40cca:	82 30       	cpi	r24, 0x02	; 2
   40ccc:	d9 f5       	brne	.+118    	; 0x40d44 <udc_process_setup+0x4b8>
static bool udc_req_ep(void)
{
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
   40cce:	80 91 f9 28 	lds	r24, 0x28F9
   40cd2:	88 23       	and	r24, r24
   40cd4:	89 f1       	breq	.+98     	; 0x40d38 <udc_process_setup+0x4ac>
		return false; // The device is not is configured state yet
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   40cd6:	e0 91 f7 28 	lds	r30, 0x28F7
   40cda:	f0 91 f8 28 	lds	r31, 0x28F8
   40cde:	a0 81       	ld	r26, Z
   40ce0:	b1 81       	ldd	r27, Z+1	; 0x01
   40ce2:	14 96       	adiw	r26, 0x04	; 4
   40ce4:	8c 91       	ld	r24, X
   40ce6:	88 23       	and	r24, r24
   40ce8:	49 f1       	breq	.+82     	; 0x40d3c <udc_process_setup+0x4b0>
   40cea:	10 e0       	ldi	r17, 0x00	; 0
			iface_num++) {
		// Select the interface with the current alternate setting
		udi_api = udc_ptr_conf->udi_apis[iface_num];
   40cec:	21 2f       	mov	r18, r17
   40cee:	30 e0       	ldi	r19, 0x00	; 0
   40cf0:	22 0f       	add	r18, r18
   40cf2:	33 1f       	adc	r19, r19
   40cf4:	02 80       	ldd	r0, Z+2	; 0x02
   40cf6:	f3 81       	ldd	r31, Z+3	; 0x03
   40cf8:	e0 2d       	mov	r30, r0
   40cfa:	e2 0f       	add	r30, r18
   40cfc:	f3 1f       	adc	r31, r19
   40cfe:	c0 81       	ld	r28, Z
   40d00:	d1 81       	ldd	r29, Z+1	; 0x01
		if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
   40d02:	ee 81       	ldd	r30, Y+6	; 0x06
   40d04:	ff 81       	ldd	r31, Y+7	; 0x07
   40d06:	19 95       	eicall
   40d08:	68 2f       	mov	r22, r24
   40d0a:	81 2f       	mov	r24, r17
   40d0c:	eb dc       	rcall	.-1578   	; 0x406e4 <udc_update_iface_desc>
   40d0e:	08 2f       	mov	r16, r24
   40d10:	88 23       	and	r24, r24
   40d12:	21 f1       	breq	.+72     	; 0x40d5c <udc_process_setup+0x4d0>
			return false;
		}

		// Send the SETUP request to the UDI
		if (udi_api->setup()) {
   40d14:	ec 81       	ldd	r30, Y+4	; 0x04
   40d16:	fd 81       	ldd	r31, Y+5	; 0x05
   40d18:	19 95       	eicall
   40d1a:	08 2f       	mov	r16, r24
   40d1c:	81 11       	cpse	r24, r1
   40d1e:	1e c0       	rjmp	.+60     	; 0x40d5c <udc_process_setup+0x4d0>
		return false; // The device is not is configured state yet
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
			iface_num++) {
   40d20:	1f 5f       	subi	r17, 0xFF	; 255
	if (0 == udc_num_configuration) {
		return false; // The device is not is configured state yet
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   40d22:	e0 91 f7 28 	lds	r30, 0x28F7
   40d26:	f0 91 f8 28 	lds	r31, 0x28F8
   40d2a:	a0 81       	ld	r26, Z
   40d2c:	b1 81       	ldd	r27, Z+1	; 0x01
   40d2e:	14 96       	adiw	r26, 0x04	; 4
   40d30:	8c 91       	ld	r24, X
   40d32:	18 17       	cp	r17, r24
   40d34:	d8 f2       	brcs	.-74     	; 0x40cec <udc_process_setup+0x460>
   40d36:	12 c0       	rjmp	.+36     	; 0x40d5c <udc_process_setup+0x4d0>
{
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
		return false; // The device is not is configured state yet
   40d38:	00 e0       	ldi	r16, 0x00	; 0
   40d3a:	10 c0       	rjmp	.+32     	; 0x40d5c <udc_process_setup+0x4d0>
		// Send the SETUP request to the UDI
		if (udi_api->setup()) {
			return true;
		}
	}
	return false;
   40d3c:	00 e0       	ldi	r16, 0x00	; 0
   40d3e:	0e c0       	rjmp	.+28     	; 0x40d5c <udc_process_setup+0x4d0>
	udd_g_ctrlreq.callback = NULL;
	udd_g_ctrlreq.over_under_run = NULL;

	if (Udd_setup_is_in()) {
		if (udd_g_ctrlreq.req.wLength == 0) {
			return false; // Error from USB host
   40d40:	00 e0       	ldi	r16, 0x00	; 0
   40d42:	0c c0       	rjmp	.+24     	; 0x40d5c <udc_process_setup+0x4d0>
	// Here SETUP request unknown by UDC and UDIs
#ifdef USB_DEVICE_SPECIFIC_REQUEST
	// Try to decode it in specific callback
	return USB_DEVICE_SPECIFIC_REQUEST(); // Ex: Vendor request,...
#else
	return false;
   40d44:	00 e0       	ldi	r16, 0x00	; 0
   40d46:	0a c0       	rjmp	.+20     	; 0x40d5c <udc_process_setup+0x4d0>
			return false; // Error from USB host
		}
	}

	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
   40d48:	82 2f       	mov	r24, r18
   40d4a:	80 76       	andi	r24, 0x60	; 96
   40d4c:	09 f0       	breq	.+2      	; 0x40d50 <udc_process_setup+0x4c4>
   40d4e:	7d cf       	rjmp	.-262    	; 0x40c4a <udc_process_setup+0x3be>
   40d50:	bf ce       	rjmp	.-642    	; 0x40ad0 <udc_process_setup+0x244>
   40d52:	32 2f       	mov	r19, r18
   40d54:	30 76       	andi	r19, 0x60	; 96
   40d56:	09 f0       	breq	.+2      	; 0x40d5a <udc_process_setup+0x4ce>
   40d58:	78 cf       	rjmp	.-272    	; 0x40c4a <udc_process_setup+0x3be>
   40d5a:	b9 cd       	rjmp	.-1166   	; 0x408ce <udc_process_setup+0x42>
	// Try to decode it in specific callback
	return USB_DEVICE_SPECIFIC_REQUEST(); // Ex: Vendor request,...
#else
	return false;
#endif
}
   40d5c:	80 2f       	mov	r24, r16
   40d5e:	df 91       	pop	r29
   40d60:	cf 91       	pop	r28
   40d62:	1f 91       	pop	r17
   40d64:	0f 91       	pop	r16
   40d66:	ff 90       	pop	r15
   40d68:	ef 90       	pop	r14
   40d6a:	08 95       	ret

00040d6c <udd_ctrl_init>:
#ifndef UDD_NO_SLEEP_MGR
	if (!udd_b_idle)
#endif
	{
		udd_sleep_mode(true); // Enter in IDLE mode
		udd_send_remote_wake_up();
   40d6c:	0f 93       	push	r16
   40d6e:	e8 ec       	ldi	r30, 0xC8	; 200
   40d70:	f4 e0       	ldi	r31, 0x04	; 4
   40d72:	80 81       	ld	r24, Z
   40d74:	8f 7d       	andi	r24, 0xDF	; 223
   40d76:	80 83       	st	Z, r24
   40d78:	80 81       	ld	r24, Z
   40d7a:	8f 7d       	andi	r24, 0xDF	; 223
   40d7c:	80 83       	st	Z, r24
   40d7e:	e0 e5       	ldi	r30, 0x50	; 80
   40d80:	f9 e2       	ldi	r31, 0x29	; 41
   40d82:	02 e0       	ldi	r16, 0x02	; 2
   40d84:	05 93       	las	Z, r16
   40d86:	10 92 52 29 	sts	0x2952, r1
   40d8a:	10 92 53 29 	sts	0x2953, r1
   40d8e:	00 e2       	ldi	r16, 0x20	; 32
   40d90:	06 93       	lac	Z, r16
   40d92:	00 e4       	ldi	r16, 0x40	; 64
   40d94:	06 93       	lac	Z, r16
   40d96:	e8 e4       	ldi	r30, 0x48	; 72
   40d98:	f9 e2       	ldi	r31, 0x29	; 41
   40d9a:	00 e2       	ldi	r16, 0x20	; 32
   40d9c:	06 93       	lac	Z, r16
   40d9e:	00 e4       	ldi	r16, 0x40	; 64
   40da0:	06 93       	lac	Z, r16
   40da2:	10 92 6f 29 	sts	0x296F, r1
   40da6:	10 92 70 29 	sts	0x2970, r1
   40daa:	10 92 71 29 	sts	0x2971, r1
   40dae:	10 92 72 29 	sts	0x2972, r1
   40db2:	10 92 6d 29 	sts	0x296D, r1
   40db6:	10 92 6e 29 	sts	0x296E, r1
   40dba:	10 92 41 29 	sts	0x2941, r1
   40dbe:	0f 91       	pop	r16
   40dc0:	08 95       	ret

00040dc2 <udd_ctrl_stall_data>:
   40dc2:	0f 93       	push	r16
   40dc4:	85 e0       	ldi	r24, 0x05	; 5
   40dc6:	80 93 41 29 	sts	0x2941, r24
   40dca:	e1 e5       	ldi	r30, 0x51	; 81
   40dcc:	f9 e2       	ldi	r31, 0x29	; 41
   40dce:	04 e0       	ldi	r16, 0x04	; 4
   40dd0:	05 93       	las	Z, r16
   40dd2:	e9 e4       	ldi	r30, 0x49	; 73
   40dd4:	f9 e2       	ldi	r31, 0x29	; 41
   40dd6:	04 e0       	ldi	r16, 0x04	; 4
   40dd8:	05 93       	las	Z, r16
   40dda:	0f 91       	pop	r16
   40ddc:	08 95       	ret

00040dde <udd_ctrl_send_zlp_in>:
   40dde:	0f 93       	push	r16
   40de0:	83 e0       	ldi	r24, 0x03	; 3
   40de2:	80 93 41 29 	sts	0x2941, r24
   40de6:	10 92 52 29 	sts	0x2952, r1
   40dea:	10 92 53 29 	sts	0x2953, r1
   40dee:	e0 e5       	ldi	r30, 0x50	; 80
   40df0:	f9 e2       	ldi	r31, 0x29	; 41
   40df2:	02 e0       	ldi	r16, 0x02	; 2
   40df4:	06 93       	lac	Z, r16
   40df6:	0f 91       	pop	r16
   40df8:	08 95       	ret

00040dfa <udd_ctrl_endofrequest>:
   40dfa:	e0 91 6f 29 	lds	r30, 0x296F
   40dfe:	f0 91 70 29 	lds	r31, 0x2970
   40e02:	30 97       	sbiw	r30, 0x00	; 0
   40e04:	09 f0       	breq	.+2      	; 0x40e08 <udd_ctrl_endofrequest+0xe>
   40e06:	19 95       	eicall
   40e08:	08 95       	ret

00040e0a <udd_ctrl_in_sent>:
   40e0a:	0f 93       	push	r16
   40e0c:	cf 93       	push	r28
   40e0e:	df 93       	push	r29
   40e10:	80 91 41 29 	lds	r24, 0x2941
   40e14:	83 30       	cpi	r24, 0x03	; 3
   40e16:	19 f4       	brne	.+6      	; 0x40e1e <udd_ctrl_in_sent+0x14>
   40e18:	f0 df       	rcall	.-32     	; 0x40dfa <udd_ctrl_endofrequest>
   40e1a:	a8 df       	rcall	.-176    	; 0x40d6c <udd_ctrl_init>
   40e1c:	60 c0       	rjmp	.+192    	; 0x40ede <udd_ctrl_in_sent+0xd4>
   40e1e:	80 91 3d 29 	lds	r24, 0x293D
   40e22:	90 91 3e 29 	lds	r25, 0x293E
   40e26:	c0 91 6d 29 	lds	r28, 0x296D
   40e2a:	d0 91 6e 29 	lds	r29, 0x296E
   40e2e:	c8 1b       	sub	r28, r24
   40e30:	d9 0b       	sbc	r29, r25
   40e32:	71 f5       	brne	.+92     	; 0x40e90 <udd_ctrl_in_sent+0x86>
   40e34:	20 91 3f 29 	lds	r18, 0x293F
   40e38:	30 91 40 29 	lds	r19, 0x2940
   40e3c:	82 0f       	add	r24, r18
   40e3e:	93 1f       	adc	r25, r19
   40e40:	80 93 3f 29 	sts	0x293F, r24
   40e44:	90 93 40 29 	sts	0x2940, r25
   40e48:	20 91 69 29 	lds	r18, 0x2969
   40e4c:	30 91 6a 29 	lds	r19, 0x296A
   40e50:	82 17       	cp	r24, r18
   40e52:	93 07       	cpc	r25, r19
   40e54:	21 f0       	breq	.+8      	; 0x40e5e <udd_ctrl_in_sent+0x54>
   40e56:	80 91 fc 28 	lds	r24, 0x28FC
   40e5a:	88 23       	and	r24, r24
   40e5c:	41 f0       	breq	.+16     	; 0x40e6e <udd_ctrl_in_sent+0x64>
   40e5e:	84 e0       	ldi	r24, 0x04	; 4
   40e60:	80 93 41 29 	sts	0x2941, r24
   40e64:	e8 e4       	ldi	r30, 0x48	; 72
   40e66:	f9 e2       	ldi	r31, 0x29	; 41
   40e68:	02 e0       	ldi	r16, 0x02	; 2
   40e6a:	06 93       	lac	Z, r16
   40e6c:	38 c0       	rjmp	.+112    	; 0x40ede <udd_ctrl_in_sent+0xd4>
   40e6e:	e0 91 71 29 	lds	r30, 0x2971
   40e72:	f0 91 72 29 	lds	r31, 0x2972
   40e76:	30 97       	sbiw	r30, 0x00	; 0
   40e78:	99 f0       	breq	.+38     	; 0x40ea0 <udd_ctrl_in_sent+0x96>
   40e7a:	19 95       	eicall
   40e7c:	88 23       	and	r24, r24
   40e7e:	81 f0       	breq	.+32     	; 0x40ea0 <udd_ctrl_in_sent+0x96>
   40e80:	10 92 3d 29 	sts	0x293D, r1
   40e84:	10 92 3e 29 	sts	0x293E, r1
   40e88:	c0 91 6d 29 	lds	r28, 0x296D
   40e8c:	d0 91 6e 29 	lds	r29, 0x296E
   40e90:	c0 34       	cpi	r28, 0x40	; 64
   40e92:	d1 05       	cpc	r29, r1
   40e94:	28 f0       	brcs	.+10     	; 0x40ea0 <udd_ctrl_in_sent+0x96>
   40e96:	10 92 fc 28 	sts	0x28FC, r1
   40e9a:	c0 e4       	ldi	r28, 0x40	; 64
   40e9c:	d0 e0       	ldi	r29, 0x00	; 0
   40e9e:	03 c0       	rjmp	.+6      	; 0x40ea6 <udd_ctrl_in_sent+0x9c>
   40ea0:	81 e0       	ldi	r24, 0x01	; 1
   40ea2:	80 93 fc 28 	sts	0x28FC, r24
   40ea6:	c0 93 52 29 	sts	0x2952, r28
   40eaa:	d0 93 53 29 	sts	0x2953, r29
   40eae:	80 91 3d 29 	lds	r24, 0x293D
   40eb2:	90 91 3e 29 	lds	r25, 0x293E
   40eb6:	20 91 6b 29 	lds	r18, 0x296B
   40eba:	30 91 6c 29 	lds	r19, 0x296C
   40ebe:	28 0f       	add	r18, r24
   40ec0:	39 1f       	adc	r19, r25
   40ec2:	20 93 54 29 	sts	0x2954, r18
   40ec6:	30 93 55 29 	sts	0x2955, r19
   40eca:	c8 0f       	add	r28, r24
   40ecc:	d9 1f       	adc	r29, r25
   40ece:	c0 93 3d 29 	sts	0x293D, r28
   40ed2:	d0 93 3e 29 	sts	0x293E, r29
   40ed6:	e0 e5       	ldi	r30, 0x50	; 80
   40ed8:	f9 e2       	ldi	r31, 0x29	; 41
   40eda:	02 e0       	ldi	r16, 0x02	; 2
   40edc:	06 93       	lac	Z, r16
   40ede:	df 91       	pop	r29
   40ee0:	cf 91       	pop	r28
   40ee2:	0f 91       	pop	r16
   40ee4:	08 95       	ret

00040ee6 <udd_ctrl_interrupt_tc_setup>:
   40ee6:	0f 93       	push	r16
   40ee8:	cf 93       	push	r28
   40eea:	80 91 cc 04 	lds	r24, 0x04CC
   40eee:	80 ff       	sbrs	r24, 0
   40ef0:	62 c0       	rjmp	.+196    	; 0x40fb6 <udd_ctrl_interrupt_tc_setup+0xd0>
   40ef2:	81 e0       	ldi	r24, 0x01	; 1
   40ef4:	80 93 cc 04 	sts	0x04CC, r24
   40ef8:	e8 e4       	ldi	r30, 0x48	; 72
   40efa:	f9 e2       	ldi	r31, 0x29	; 41
   40efc:	00 e8       	ldi	r16, 0x80	; 128
   40efe:	06 93       	lac	Z, r16
   40f00:	e0 e5       	ldi	r30, 0x50	; 80
   40f02:	f9 e2       	ldi	r31, 0x29	; 41
   40f04:	00 e8       	ldi	r16, 0x80	; 128
   40f06:	06 93       	lac	Z, r16
   40f08:	80 93 ca 04 	sts	0x04CA, r24
   40f0c:	e8 e4       	ldi	r30, 0x48	; 72
   40f0e:	f9 e2       	ldi	r31, 0x29	; 41
   40f10:	00 e1       	ldi	r16, 0x10	; 16
   40f12:	06 93       	lac	Z, r16
   40f14:	80 91 41 29 	lds	r24, 0x2941
   40f18:	88 23       	and	r24, r24
   40f1a:	29 f0       	breq	.+10     	; 0x40f26 <udd_ctrl_interrupt_tc_setup+0x40>
   40f1c:	83 50       	subi	r24, 0x03	; 3
   40f1e:	82 30       	cpi	r24, 0x02	; 2
   40f20:	08 f4       	brcc	.+2      	; 0x40f24 <udd_ctrl_interrupt_tc_setup+0x3e>
   40f22:	6b df       	rcall	.-298    	; 0x40dfa <udd_ctrl_endofrequest>
   40f24:	23 df       	rcall	.-442    	; 0x40d6c <udd_ctrl_init>
   40f26:	80 91 4a 29 	lds	r24, 0x294A
   40f2a:	90 91 4b 29 	lds	r25, 0x294B
   40f2e:	08 97       	sbiw	r24, 0x08	; 8
   40f30:	09 f0       	breq	.+2      	; 0x40f34 <udd_ctrl_interrupt_tc_setup+0x4e>
   40f32:	43 c0       	rjmp	.+134    	; 0x40fba <udd_ctrl_interrupt_tc_setup+0xd4>
   40f34:	88 e0       	ldi	r24, 0x08	; 8
   40f36:	ed ef       	ldi	r30, 0xFD	; 253
   40f38:	f8 e2       	ldi	r31, 0x28	; 40
   40f3a:	a3 e6       	ldi	r26, 0x63	; 99
   40f3c:	b9 e2       	ldi	r27, 0x29	; 41
   40f3e:	01 90       	ld	r0, Z+
   40f40:	0d 92       	st	X+, r0
   40f42:	8a 95       	dec	r24
   40f44:	e1 f7       	brne	.-8      	; 0x40f3e <udd_ctrl_interrupt_tc_setup+0x58>
   40f46:	e8 ec       	ldi	r30, 0xC8	; 200
   40f48:	f4 e0       	ldi	r31, 0x04	; 4
   40f4a:	80 81       	ld	r24, Z
   40f4c:	80 62       	ori	r24, 0x20	; 32
   40f4e:	80 83       	st	Z, r24
   40f50:	80 81       	ld	r24, Z
   40f52:	80 62       	ori	r24, 0x20	; 32
   40f54:	80 83       	st	Z, r24
   40f56:	9a dc       	rcall	.-1740   	; 0x4088c <udc_process_setup>
   40f58:	c8 2f       	mov	r28, r24
   40f5a:	81 11       	cpse	r24, r1
   40f5c:	03 c0       	rjmp	.+6      	; 0x40f64 <udd_ctrl_interrupt_tc_setup+0x7e>
   40f5e:	31 df       	rcall	.-414    	; 0x40dc2 <udd_ctrl_stall_data>
   40f60:	c1 e0       	ldi	r28, 0x01	; 1
   40f62:	2c c0       	rjmp	.+88     	; 0x40fbc <udd_ctrl_interrupt_tc_setup+0xd6>
   40f64:	80 91 63 29 	lds	r24, 0x2963
   40f68:	88 23       	and	r24, r24
   40f6a:	6c f4       	brge	.+26     	; 0x40f86 <udd_ctrl_interrupt_tc_setup+0xa0>
   40f6c:	10 92 3f 29 	sts	0x293F, r1
   40f70:	10 92 40 29 	sts	0x2940, r1
   40f74:	10 92 3d 29 	sts	0x293D, r1
   40f78:	10 92 3e 29 	sts	0x293E, r1
   40f7c:	82 e0       	ldi	r24, 0x02	; 2
   40f7e:	80 93 41 29 	sts	0x2941, r24
   40f82:	43 df       	rcall	.-378    	; 0x40e0a <udd_ctrl_in_sent>
   40f84:	1b c0       	rjmp	.+54     	; 0x40fbc <udd_ctrl_interrupt_tc_setup+0xd6>
   40f86:	20 91 69 29 	lds	r18, 0x2969
   40f8a:	30 91 6a 29 	lds	r19, 0x296A
   40f8e:	23 2b       	or	r18, r19
   40f90:	11 f4       	brne	.+4      	; 0x40f96 <udd_ctrl_interrupt_tc_setup+0xb0>
   40f92:	25 df       	rcall	.-438    	; 0x40dde <udd_ctrl_send_zlp_in>
   40f94:	13 c0       	rjmp	.+38     	; 0x40fbc <udd_ctrl_interrupt_tc_setup+0xd6>
   40f96:	10 92 3f 29 	sts	0x293F, r1
   40f9a:	10 92 40 29 	sts	0x2940, r1
   40f9e:	10 92 3d 29 	sts	0x293D, r1
   40fa2:	10 92 3e 29 	sts	0x293E, r1
   40fa6:	81 e0       	ldi	r24, 0x01	; 1
   40fa8:	80 93 41 29 	sts	0x2941, r24
   40fac:	e8 e4       	ldi	r30, 0x48	; 72
   40fae:	f9 e2       	ldi	r31, 0x29	; 41
   40fb0:	02 e0       	ldi	r16, 0x02	; 2
   40fb2:	06 93       	lac	Z, r16
   40fb4:	03 c0       	rjmp	.+6      	; 0x40fbc <udd_ctrl_interrupt_tc_setup+0xd6>
   40fb6:	c0 e0       	ldi	r28, 0x00	; 0
   40fb8:	01 c0       	rjmp	.+2      	; 0x40fbc <udd_ctrl_interrupt_tc_setup+0xd6>
   40fba:	c1 e0       	ldi	r28, 0x01	; 1
   40fbc:	8c 2f       	mov	r24, r28
   40fbe:	cf 91       	pop	r28
   40fc0:	0f 91       	pop	r16
   40fc2:	08 95       	ret

00040fc4 <udd_attach>:
   40fc4:	8f b7       	in	r24, 0x3f	; 63
   40fc6:	f8 94       	cli
   40fc8:	ea ec       	ldi	r30, 0xCA	; 202
   40fca:	f4 e0       	ldi	r31, 0x04	; 4
   40fcc:	90 e4       	ldi	r25, 0x40	; 64
   40fce:	90 83       	st	Z, r25
   40fd0:	90 e2       	ldi	r25, 0x20	; 32
   40fd2:	90 83       	st	Z, r25
   40fd4:	e1 ec       	ldi	r30, 0xC1	; 193
   40fd6:	f4 e0       	ldi	r31, 0x04	; 4
   40fd8:	90 81       	ld	r25, Z
   40fda:	91 60       	ori	r25, 0x01	; 1
   40fdc:	90 83       	st	Z, r25
   40fde:	a9 ec       	ldi	r26, 0xC9	; 201
   40fe0:	b4 e0       	ldi	r27, 0x04	; 4
   40fe2:	9c 91       	ld	r25, X
   40fe4:	92 60       	ori	r25, 0x02	; 2
   40fe6:	9c 93       	st	X, r25
   40fe8:	e8 ec       	ldi	r30, 0xC8	; 200
   40fea:	f4 e0       	ldi	r31, 0x04	; 4
   40fec:	90 81       	ld	r25, Z
   40fee:	90 64       	ori	r25, 0x40	; 64
   40ff0:	90 83       	st	Z, r25
   40ff2:	9c 91       	ld	r25, X
   40ff4:	91 60       	ori	r25, 0x01	; 1
   40ff6:	9c 93       	st	X, r25
   40ff8:	90 81       	ld	r25, Z
   40ffa:	90 68       	ori	r25, 0x80	; 128
   40ffc:	90 83       	st	Z, r25
   40ffe:	8f bf       	out	0x3f, r24	; 63
   41000:	08 95       	ret

00041002 <udd_enable>:
   41002:	cf 93       	push	r28
   41004:	df 93       	push	r29
   41006:	c0 e6       	ldi	r28, 0x60	; 96
   41008:	d0 e0       	ldi	r29, 0x00	; 0
   4100a:	18 82       	st	Y, r1
   4100c:	80 e3       	ldi	r24, 0x30	; 48
   4100e:	90 d2       	rcall	.+1312   	; 0x41530 <sysclk_enable_usb>
   41010:	e0 ec       	ldi	r30, 0xC0	; 192
   41012:	f4 e0       	ldi	r31, 0x04	; 4
   41014:	80 81       	ld	r24, Z
   41016:	80 64       	ori	r24, 0x40	; 64
   41018:	80 83       	st	Z, r24
   4101a:	81 e0       	ldi	r24, 0x01	; 1
   4101c:	88 83       	st	Y, r24
   4101e:	cf b7       	in	r28, 0x3f	; 63
   41020:	f8 94       	cli
   41022:	10 92 49 29 	sts	0x2949, r1
   41026:	10 92 51 29 	sts	0x2951, r1
   4102a:	6a e1       	ldi	r22, 0x1A	; 26
   4102c:	70 e0       	ldi	r23, 0x00	; 0
   4102e:	82 e0       	ldi	r24, 0x02	; 2
   41030:	b1 d4       	rcall	.+2402   	; 0x41994 <nvm_read_byte>
   41032:	8f 3f       	cpi	r24, 0xFF	; 255
   41034:	19 f0       	breq	.+6      	; 0x4103c <udd_enable+0x3a>
   41036:	80 93 fa 04 	sts	0x04FA, r24
   4103a:	03 c0       	rjmp	.+6      	; 0x41042 <udd_enable+0x40>
   4103c:	8f e1       	ldi	r24, 0x1F	; 31
   4103e:	80 93 fa 04 	sts	0x04FA, r24
   41042:	6b e1       	ldi	r22, 0x1B	; 27
   41044:	70 e0       	ldi	r23, 0x00	; 0
   41046:	82 e0       	ldi	r24, 0x02	; 2
   41048:	a5 d4       	rcall	.+2378   	; 0x41994 <nvm_read_byte>
   4104a:	8f 3f       	cpi	r24, 0xFF	; 255
   4104c:	19 f0       	breq	.+6      	; 0x41054 <udd_enable+0x52>
   4104e:	80 93 fb 04 	sts	0x04FB, r24
   41052:	03 c0       	rjmp	.+6      	; 0x4105a <udd_enable+0x58>
   41054:	8f e1       	ldi	r24, 0x1F	; 31
   41056:	80 93 fb 04 	sts	0x04FB, r24
   4105a:	e0 ec       	ldi	r30, 0xC0	; 192
   4105c:	f4 e0       	ldi	r31, 0x04	; 4
   4105e:	80 81       	ld	r24, Z
   41060:	80 83       	st	Z, r24
   41062:	80 81       	ld	r24, Z
   41064:	80 68       	ori	r24, 0x80	; 128
   41066:	80 83       	st	Z, r24
   41068:	80 81       	ld	r24, Z
   4106a:	80 61       	ori	r24, 0x10	; 16
   4106c:	80 83       	st	Z, r24
   4106e:	88 e4       	ldi	r24, 0x48	; 72
   41070:	99 e2       	ldi	r25, 0x29	; 41
   41072:	86 83       	std	Z+6, r24	; 0x06
   41074:	97 83       	std	Z+7, r25	; 0x07
   41076:	80 81       	ld	r24, Z
   41078:	80 62       	ori	r24, 0x20	; 32
   4107a:	80 83       	st	Z, r24
   4107c:	8f ef       	ldi	r24, 0xFF	; 255
   4107e:	80 93 c5 04 	sts	0x04C5, r24
   41082:	e8 ec       	ldi	r30, 0xC8	; 200
   41084:	f4 e0       	ldi	r31, 0x04	; 4
   41086:	80 81       	ld	r24, Z
   41088:	81 60       	ori	r24, 0x01	; 1
   4108a:	80 83       	st	Z, r24
   4108c:	9b df       	rcall	.-202    	; 0x40fc4 <udd_attach>
   4108e:	cf bf       	out	0x3f, r28	; 63
   41090:	df 91       	pop	r29
   41092:	cf 91       	pop	r28
   41094:	08 95       	ret

00041096 <udd_set_address>:
   41096:	80 93 c3 04 	sts	0x04C3, r24
   4109a:	08 95       	ret

0004109c <udd_getaddress>:
   4109c:	80 91 c3 04 	lds	r24, 0x04C3
   410a0:	08 95       	ret

000410a2 <udd_set_setup_payload>:
	}
}

void udd_set_setup_payload( uint8_t *payload, uint16_t payload_size )
{
	udd_g_ctrlreq.payload = payload;
   410a2:	80 93 6b 29 	sts	0x296B, r24
   410a6:	90 93 6c 29 	sts	0x296C, r25
	udd_g_ctrlreq.payload_size = payload_size;
   410aa:	60 93 6d 29 	sts	0x296D, r22
   410ae:	70 93 6e 29 	sts	0x296E, r23
   410b2:	08 95       	ret

000410b4 <__vector_125>:
 * USB bus event interrupt includes :
 * - USB line events SOF, reset, suspend, resume, wakeup
 * - endpoint control errors underflow, overflow, stall
 */
ISR(USB_BUSEVENT_vect)
{
   410b4:	1f 92       	push	r1
   410b6:	0f 92       	push	r0
   410b8:	0f b6       	in	r0, 0x3f	; 63
   410ba:	0f 92       	push	r0
   410bc:	11 24       	eor	r1, r1
   410be:	0b b6       	in	r0, 0x3b	; 59
   410c0:	0f 92       	push	r0
   410c2:	0f 93       	push	r16
   410c4:	2f 93       	push	r18
   410c6:	3f 93       	push	r19
   410c8:	4f 93       	push	r20
   410ca:	5f 93       	push	r21
   410cc:	6f 93       	push	r22
   410ce:	7f 93       	push	r23
   410d0:	8f 93       	push	r24
   410d2:	9f 93       	push	r25
   410d4:	af 93       	push	r26
   410d6:	bf 93       	push	r27
   410d8:	ef 93       	push	r30
   410da:	ff 93       	push	r31
	VPORT1.OUT = 0x04;	// Red LED
   410dc:	84 e0       	ldi	r24, 0x04	; 4
   410de:	85 bb       	out	0x15, r24	; 21
	if (udd_is_start_of_frame_event()) {
   410e0:	80 91 cb 04 	lds	r24, 0x04CB
   410e4:	88 23       	and	r24, r24
   410e6:	2c f4       	brge	.+10     	; 0x410f2 <__vector_125+0x3e>
		udd_ack_start_of_frame_event();
   410e8:	80 e8       	ldi	r24, 0x80	; 128
   410ea:	80 93 ca 04 	sts	0x04CA, r24
		udc_sof_notify();
   410ee:	9f db       	rcall	.-2242   	; 0x4082e <udc_sof_notify>
#ifdef UDC_SOF_EVENT
		UDC_SOF_EVENT();
#endif
		goto udd_interrupt_bus_event_end;
   410f0:	7f c0       	rjmp	.+254    	; 0x411f0 <__vector_125+0x13c>
}

static bool udd_ctrl_interrupt_error(void)
{
	// Underflow only managed for control endpoint
	if (udd_is_underflow_event()) {
   410f2:	80 91 cb 04 	lds	r24, 0x04CB
   410f6:	82 ff       	sbrs	r24, 2
   410f8:	20 c0       	rjmp	.+64     	; 0x4113a <__vector_125+0x86>
		udd_ack_underflow_event();
   410fa:	84 e0       	ldi	r24, 0x04	; 4
   410fc:	80 93 ca 04 	sts	0x04CA, r24
		if (udd_control_in_underflow()) {
   41100:	80 91 50 29 	lds	r24, 0x2950
   41104:	86 ff       	sbrs	r24, 6
   41106:	74 c0       	rjmp	.+232    	; 0x411f0 <__vector_125+0x13c>
	udd_control_out_clear_NACK0();
}

static void udd_ctrl_underflow(void)
{
	if (udd_is_tc_event() || udd_ctrl_interrupt_tc_setup()) {
   41108:	80 91 cc 04 	lds	r24, 0x04CC
   4110c:	81 fd       	sbrc	r24, 1
   4110e:	70 c0       	rjmp	.+224    	; 0x411f0 <__vector_125+0x13c>
   41110:	ea de       	rcall	.-556    	; 0x40ee6 <udd_ctrl_interrupt_tc_setup>
   41112:	81 11       	cpse	r24, r1
   41114:	6d c0       	rjmp	.+218    	; 0x411f0 <__vector_125+0x13c>
		return; // underflow ignored if a transfer complete has been no processed
	}
	if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) {
   41116:	80 91 41 29 	lds	r24, 0x2941
   4111a:	81 30       	cpi	r24, 0x01	; 1
   4111c:	11 f4       	brne	.+4      	; 0x41122 <__vector_125+0x6e>
		// Host want to stop OUT transaction
		// then stop to wait OUT data phase and wait IN ZLP handshake
		udd_ctrl_send_zlp_in();
   4111e:	5f de       	rcall	.-834    	; 0x40dde <udd_ctrl_send_zlp_in>
   41120:	67 c0       	rjmp	.+206    	; 0x411f0 <__vector_125+0x13c>
	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
   41122:	84 30       	cpi	r24, 0x04	; 4
   41124:	09 f0       	breq	.+2      	; 0x41128 <__vector_125+0x74>
   41126:	64 c0       	rjmp	.+200    	; 0x411f0 <__vector_125+0x13c>
		// A OUT handshake is waiting by device,
		// but host want extra IN data then stall extra IN data and following status stage
		udd_control_in_enable_stall();
   41128:	e1 e5       	ldi	r30, 0x51	; 81
   4112a:	f9 e2       	ldi	r31, 0x29	; 41
   4112c:	04 e0       	ldi	r16, 0x04	; 4
   4112e:	05 93       	las	Z, r16
		udd_control_out_enable_stall();
   41130:	e9 e4       	ldi	r30, 0x49	; 73
   41132:	f9 e2       	ldi	r31, 0x29	; 41
   41134:	04 e0       	ldi	r16, 0x04	; 4
   41136:	05 93       	las	Z, r16
   41138:	5b c0       	rjmp	.+182    	; 0x411f0 <__vector_125+0x13c>
			udd_ctrl_underflow();
		}
		return true;
	}
	// Overflow only managed for control endpoint
	if (udd_is_overflow_event()) {
   4113a:	80 91 cb 04 	lds	r24, 0x04CB
   4113e:	81 ff       	sbrs	r24, 1
   41140:	52 c0       	rjmp	.+164    	; 0x411e6 <__vector_125+0x132>
		udd_ack_overflow_event();
   41142:	82 e0       	ldi	r24, 0x02	; 2
   41144:	80 93 ca 04 	sts	0x04CA, r24
		if (udd_control_out_overflow()) {
   41148:	80 91 48 29 	lds	r24, 0x2948
   4114c:	86 ff       	sbrs	r24, 6
   4114e:	50 c0       	rjmp	.+160    	; 0x411f0 <__vector_125+0x13c>
	}
}

static void udd_ctrl_overflow(void)
{
	if (udd_is_tc_event() || udd_ctrl_interrupt_tc_setup()) {
   41150:	80 91 cc 04 	lds	r24, 0x04CC
   41154:	81 fd       	sbrc	r24, 1
   41156:	4c c0       	rjmp	.+152    	; 0x411f0 <__vector_125+0x13c>
   41158:	c6 de       	rcall	.-628    	; 0x40ee6 <udd_ctrl_interrupt_tc_setup>
   4115a:	81 11       	cpse	r24, r1
   4115c:	49 c0       	rjmp	.+146    	; 0x411f0 <__vector_125+0x13c>
		return; // overflow ignored if a transfer complete has been no processed
	}
	if (UDD_EPCTRL_DATA_IN == udd_ep_control_state) {
   4115e:	80 91 41 29 	lds	r24, 0x2941
   41162:	82 30       	cpi	r24, 0x02	; 2
   41164:	41 f4       	brne	.+16     	; 0x41176 <__vector_125+0xc2>
	udd_control_in_clear_NACK0();
}

static void udd_ctrl_send_zlp_out(void)
{
	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
   41166:	84 e0       	ldi	r24, 0x04	; 4
   41168:	80 93 41 29 	sts	0x2941, r24
	// Valid reception of OUT packet on control endpoint
	udd_control_out_clear_NACK0();
   4116c:	e8 e4       	ldi	r30, 0x48	; 72
   4116e:	f9 e2       	ldi	r31, 0x29	; 41
   41170:	02 e0       	ldi	r16, 0x02	; 2
   41172:	06 93       	lac	Z, r16
   41174:	3d c0       	rjmp	.+122    	; 0x411f0 <__vector_125+0x13c>
	}
	if (UDD_EPCTRL_DATA_IN == udd_ep_control_state) {
		// Host want to stop IN transaction
		// then stop to wait IN data phase and wait OUT ZLP handshake
		udd_ctrl_send_zlp_out();
	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
   41176:	83 30       	cpi	r24, 0x03	; 3
   41178:	09 f0       	breq	.+2      	; 0x4117c <__vector_125+0xc8>
   4117a:	3a c0       	rjmp	.+116    	; 0x411f0 <__vector_125+0x13c>
		// A IN handshake is waiting by device,
		// but host want extra OUT data then stall extra OUT data and following status stage
		udd_control_in_enable_stall();
   4117c:	e1 e5       	ldi	r30, 0x51	; 81
   4117e:	f9 e2       	ldi	r31, 0x29	; 41
   41180:	04 e0       	ldi	r16, 0x04	; 4
   41182:	05 93       	las	Z, r16
		udd_control_out_enable_stall();
   41184:	e9 e4       	ldi	r30, 0x49	; 73
   41186:	f9 e2       	ldi	r31, 0x29	; 41
   41188:	04 e0       	ldi	r16, 0x04	; 4
   4118a:	05 93       	las	Z, r16
   4118c:	31 c0       	rjmp	.+98     	; 0x411f0 <__vector_125+0x13c>

	if (udd_ctrl_interrupt_error()) {
		goto udd_interrupt_bus_event_end;
	}
	if (udd_is_reset_event()) {
		udd_ack_reset_event();
   4118e:	80 e1       	ldi	r24, 0x10	; 16
   41190:	80 93 ca 04 	sts	0x04CA, r24
		for (i = 1; i < USB_DEVICE_MAX_EP; i++) {
			udd_ep_abort(i);
			udd_ep_abort(i | USB_EP_DIR_IN);
		}
#endif
		udc_reset();
   41194:	25 db       	rcall	.-2486   	; 0x407e0 <udc_reset>

		// Reset USB address to 0
		udd_set_device_address(0);
   41196:	10 92 c3 04 	sts	0x04C3, r1
#endif
	}

	// Enable endpoint
	ep_ctrl = udd_ep_get_ctrl(ep);
	udd_endpoint_disable(ep_ctrl);
   4119a:	e9 e4       	ldi	r30, 0x49	; 73
   4119c:	f9 e2       	ldi	r31, 0x29	; 41
   4119e:	10 82       	st	Z, r1
	udd_endpoint_clear_status(ep_ctrl);
   411a0:	96 e0       	ldi	r25, 0x06	; 6
   411a2:	90 93 48 29 	sts	0x2948, r25
	udd_endpoint_set_control(ep_ctrl, (uint8_t) type | (uint8_t) size);
   411a6:	83 e4       	ldi	r24, 0x43	; 67
   411a8:	80 83       	st	Z, r24
#endif
	}

	// Enable endpoint
	ep_ctrl = udd_ep_get_ctrl(ep);
	udd_endpoint_disable(ep_ctrl);
   411aa:	e1 e5       	ldi	r30, 0x51	; 81
   411ac:	f9 e2       	ldi	r31, 0x29	; 41
   411ae:	10 82       	st	Z, r1
	udd_endpoint_clear_status(ep_ctrl);
   411b0:	90 93 50 29 	sts	0x2950, r25
	udd_endpoint_set_control(ep_ctrl, (uint8_t) type | (uint8_t) size);
   411b4:	80 83       	st	Z, r24
		udd_set_device_address(0);
		// Alloc and configure control endpoint
		udd_ep_init(0, USB_EP_TYPE_CONTROL, USB_DEVICE_EP_CTRL_SIZE);
		udd_ep_init(0 | USB_EP_DIR_IN, USB_EP_TYPE_CONTROL,
				USB_DEVICE_EP_CTRL_SIZE);
		udd_control_out_set_buf(&udd_ctrl_buffer);
   411b6:	8d ef       	ldi	r24, 0xFD	; 253
   411b8:	98 e2       	ldi	r25, 0x28	; 40
   411ba:	80 93 4c 29 	sts	0x294C, r24
   411be:	90 93 4d 29 	sts	0x294D, r25
		// Reset endpoint control management
		udd_ctrl_init();
   411c2:	d4 dd       	rcall	.-1112   	; 0x40d6c <udd_ctrl_init>
		goto udd_interrupt_bus_event_end;
   411c4:	15 c0       	rjmp	.+42     	; 0x411f0 <__vector_125+0x13c>
	}

	if (udd_is_suspend_event()) {
   411c6:	80 91 cb 04 	lds	r24, 0x04CB
   411ca:	86 ff       	sbrs	r24, 6
   411cc:	04 c0       	rjmp	.+8      	; 0x411d6 <__vector_125+0x122>
		udd_ack_suspend_event();
   411ce:	80 e4       	ldi	r24, 0x40	; 64
   411d0:	80 93 ca 04 	sts	0x04CA, r24
		udd_sleep_mode(false); // Enter in SUSPEND mode
#ifdef UDC_SUSPEND_EVENT
		UDC_SUSPEND_EVENT();
#endif
		goto udd_interrupt_bus_event_end;
   411d4:	0d c0       	rjmp	.+26     	; 0x411f0 <__vector_125+0x13c>
	}

	if (udd_is_resume_event()) {
   411d6:	80 91 cb 04 	lds	r24, 0x04CB
   411da:	85 ff       	sbrs	r24, 5
   411dc:	09 c0       	rjmp	.+18     	; 0x411f0 <__vector_125+0x13c>
		udd_ack_resume_event();
   411de:	80 e2       	ldi	r24, 0x20	; 32
   411e0:	80 93 ca 04 	sts	0x04CA, r24
		udd_sleep_mode(true); // Enter in power reduction mode
#ifdef UDC_RESUME_EVENT
		UDC_RESUME_EVENT();
#endif
		goto udd_interrupt_bus_event_end;
   411e4:	05 c0       	rjmp	.+10     	; 0x411f0 <__vector_125+0x13c>
	}

	if (udd_ctrl_interrupt_error()) {
		goto udd_interrupt_bus_event_end;
	}
	if (udd_is_reset_event()) {
   411e6:	80 91 cb 04 	lds	r24, 0x04CB
   411ea:	84 ff       	sbrs	r24, 4
   411ec:	ec cf       	rjmp	.-40     	; 0x411c6 <__vector_125+0x112>
   411ee:	cf cf       	rjmp	.-98     	; 0x4118e <__vector_125+0xda>
		goto udd_interrupt_bus_event_end;
	}

udd_interrupt_bus_event_end:
	return;
}
   411f0:	ff 91       	pop	r31
   411f2:	ef 91       	pop	r30
   411f4:	bf 91       	pop	r27
   411f6:	af 91       	pop	r26
   411f8:	9f 91       	pop	r25
   411fa:	8f 91       	pop	r24
   411fc:	7f 91       	pop	r23
   411fe:	6f 91       	pop	r22
   41200:	5f 91       	pop	r21
   41202:	4f 91       	pop	r20
   41204:	3f 91       	pop	r19
   41206:	2f 91       	pop	r18
   41208:	0f 91       	pop	r16
   4120a:	0f 90       	pop	r0
   4120c:	0b be       	out	0x3b, r0	; 59
   4120e:	0f 90       	pop	r0
   41210:	0f be       	out	0x3f, r0	; 63
   41212:	0f 90       	pop	r0
   41214:	1f 90       	pop	r1
   41216:	18 95       	reti

00041218 <__vector_126>:
 * \brief Function called by USB transfer complete interrupt
 *
 * USB transfer complete interrupt includes events about endpoint transfer on all endpoints.
 */
ISR(USB_TRNCOMPL_vect)
{
   41218:	1f 92       	push	r1
   4121a:	0f 92       	push	r0
   4121c:	0f b6       	in	r0, 0x3f	; 63
   4121e:	0f 92       	push	r0
   41220:	11 24       	eor	r1, r1
   41222:	0b b6       	in	r0, 0x3b	; 59
   41224:	0f 92       	push	r0
   41226:	0f 93       	push	r16
   41228:	1f 93       	push	r17
   4122a:	2f 93       	push	r18
   4122c:	3f 93       	push	r19
   4122e:	4f 93       	push	r20
   41230:	5f 93       	push	r21
   41232:	6f 93       	push	r22
   41234:	7f 93       	push	r23
   41236:	8f 93       	push	r24
   41238:	9f 93       	push	r25
   4123a:	af 93       	push	r26
   4123c:	bf 93       	push	r27
   4123e:	cf 93       	push	r28
   41240:	df 93       	push	r29
   41242:	ef 93       	push	r30
   41244:	ff 93       	push	r31
	int8_t rp;
	UDD_EP_t *ep_ctrl;
	udd_ep_id_t ep;
#endif

	if (!udd_is_tc_event()) {
   41246:	80 91 cc 04 	lds	r24, 0x04CC
   4124a:	81 fd       	sbrc	r24, 1
   4124c:	03 c0       	rjmp	.+6      	; 0x41254 <__vector_126+0x3c>
		// If no other transfer complete
		// then check reception of SETUP packet on control endpoint
		if (udd_ctrl_interrupt_tc_setup()) {
   4124e:	4b de       	rcall	.-874    	; 0x40ee6 <udd_ctrl_interrupt_tc_setup>
   41250:	81 11       	cpse	r24, r1
   41252:	8a c0       	rjmp	.+276    	; 0x41368 <__vector_126+0x150>
			goto udd_interrupt_tc_end;
		}
		Assert(false);
	}
	// Check IN/OUT transfer complete on all endpoints
	udd_ack_tc_event();
   41254:	82 e0       	ldi	r24, 0x02	; 2
   41256:	80 93 cc 04 	sts	0x04CC, r24
	// Manage end of transfer on endpoint bulk/interrupt/isochronous
	udd_ep_trans_complet(ep);

#else

	udd_get_fifo_rp();
   4125a:	80 91 c5 04 	lds	r24, 0x04C5
	if (udd_endpoint_transfer_complete(udd_ep_get_ctrl(0))) {
   4125e:	80 91 48 29 	lds	r24, 0x2948
   41262:	85 ff       	sbrs	r24, 5
   41264:	7c c0       	rjmp	.+248    	; 0x4135e <__vector_126+0x146>
		udd_endpoint_ack_transfer_complete(udd_ep_get_ctrl(0));
   41266:	e8 e4       	ldi	r30, 0x48	; 72
   41268:	f9 e2       	ldi	r31, 0x29	; 41
   4126a:	00 e2       	ldi	r16, 0x20	; 32
   4126c:	06 93       	lac	Z, r16

static void udd_ctrl_out_received(void)
{
	uint16_t nb_data;

	if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
   4126e:	80 91 41 29 	lds	r24, 0x2941
   41272:	84 30       	cpi	r24, 0x04	; 4
   41274:	19 f4       	brne	.+6      	; 0x4127c <__vector_126+0x64>
		// Valid end of setup request
		udd_ctrl_endofrequest();
   41276:	c1 dd       	rcall	.-1150   	; 0x40dfa <udd_ctrl_endofrequest>
		// Reinitializes control endpoint management
		udd_ctrl_init();
   41278:	79 dd       	rcall	.-1294   	; 0x40d6c <udd_ctrl_init>
   4127a:	76 c0       	rjmp	.+236    	; 0x41368 <__vector_126+0x150>
		return;
	}
	Assert(udd_ep_control_state == UDD_EPCTRL_DATA_OUT);

	// Read data received during OUT phase
	nb_data = udd_control_out_get_bytecnt();
   4127c:	c0 91 4a 29 	lds	r28, 0x294A
   41280:	d0 91 4b 29 	lds	r29, 0x294B

	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_nb_trans + nb_data)) {
   41284:	80 91 6d 29 	lds	r24, 0x296D
   41288:	90 91 6e 29 	lds	r25, 0x296E
   4128c:	00 91 3d 29 	lds	r16, 0x293D
   41290:	10 91 3e 29 	lds	r17, 0x293E
   41294:	98 01       	movw	r18, r16
   41296:	2c 0f       	add	r18, r28
   41298:	3d 1f       	adc	r19, r29
   4129a:	82 17       	cp	r24, r18
   4129c:	93 07       	cpc	r25, r19
   4129e:	18 f4       	brcc	.+6      	; 0x412a6 <__vector_126+0x8e>
		// Payload buffer too small, ignore data remaining
		nb_data = udd_g_ctrlreq.payload_size - udd_ctrl_payload_nb_trans;
   412a0:	ec 01       	movw	r28, r24
   412a2:	c0 1b       	sub	r28, r16
   412a4:	d1 0b       	sbc	r29, r17
	}

	memcpy((uint8_t *) (udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans),
   412a6:	80 91 6b 29 	lds	r24, 0x296B
   412aa:	90 91 6c 29 	lds	r25, 0x296C
   412ae:	ae 01       	movw	r20, r28
   412b0:	6d ef       	ldi	r22, 0xFD	; 253
   412b2:	78 e2       	ldi	r23, 0x28	; 40
   412b4:	80 0f       	add	r24, r16
   412b6:	91 1f       	adc	r25, r17
   412b8:	0b d4       	rcall	.+2070   	; 0x41ad0 <memcpy>
			udd_ctrl_buffer, nb_data);
	udd_ctrl_payload_nb_trans += nb_data;
   412ba:	0c 0f       	add	r16, r28
   412bc:	1d 1f       	adc	r17, r29
   412be:	00 93 3d 29 	sts	0x293D, r16
   412c2:	10 93 3e 29 	sts	0x293E, r17

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data) || (udd_g_ctrlreq.req.wLength
   412c6:	c0 34       	cpi	r28, 0x40	; 64
   412c8:	d1 05       	cpc	r29, r1
   412ca:	69 f4       	brne	.+26     	; 0x412e6 <__vector_126+0xce>
			<= (udd_ctrl_prev_payload_nb_trans
			+ udd_ctrl_payload_nb_trans))) {
   412cc:	80 91 3f 29 	lds	r24, 0x293F
   412d0:	90 91 40 29 	lds	r25, 0x2940
   412d4:	80 0f       	add	r24, r16
   412d6:	91 1f       	adc	r25, r17

	memcpy((uint8_t *) (udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans),
			udd_ctrl_buffer, nb_data);
	udd_ctrl_payload_nb_trans += nb_data;

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data) || (udd_g_ctrlreq.req.wLength
   412d8:	20 91 69 29 	lds	r18, 0x2969
   412dc:	30 91 6a 29 	lds	r19, 0x296A
   412e0:	82 17       	cp	r24, r18
   412e2:	93 07       	cpc	r25, r19
   412e4:	88 f0       	brcs	.+34     	; 0x41308 <__vector_126+0xf0>
		// End of reception because it is a short packet
		// or all data are transfered

		// Before send ZLP, call intermediate callback
		// in case of data receive generate a stall
		udd_g_ctrlreq.payload_size = udd_ctrl_payload_nb_trans;
   412e6:	00 93 6d 29 	sts	0x296D, r16
   412ea:	10 93 6e 29 	sts	0x296E, r17
		if (NULL != udd_g_ctrlreq.over_under_run) {
   412ee:	e0 91 71 29 	lds	r30, 0x2971
   412f2:	f0 91 72 29 	lds	r31, 0x2972
   412f6:	30 97       	sbiw	r30, 0x00	; 0
   412f8:	29 f0       	breq	.+10     	; 0x41304 <__vector_126+0xec>
			if (!udd_g_ctrlreq.over_under_run()) {
   412fa:	19 95       	eicall
   412fc:	81 11       	cpse	r24, r1
   412fe:	02 c0       	rjmp	.+4      	; 0x41304 <__vector_126+0xec>
				// Stall ZLP
				udd_ctrl_stall_data();
   41300:	60 dd       	rcall	.-1344   	; 0x40dc2 <udd_ctrl_stall_data>
   41302:	32 c0       	rjmp	.+100    	; 0x41368 <__vector_126+0x150>
				return;
			}
		}
		// Send IN ZLP to ACK setup request
		udd_ctrl_send_zlp_in();
   41304:	6c dd       	rcall	.-1320   	; 0x40dde <udd_ctrl_send_zlp_in>
   41306:	30 c0       	rjmp	.+96     	; 0x41368 <__vector_126+0x150>
		return;
	}

	if (udd_g_ctrlreq.payload_size == udd_ctrl_payload_nb_trans) {
   41308:	80 91 6d 29 	lds	r24, 0x296D
   4130c:	90 91 6e 29 	lds	r25, 0x296E
   41310:	08 17       	cp	r16, r24
   41312:	19 07       	cpc	r17, r25
   41314:	f9 f4       	brne	.+62     	; 0x41354 <__vector_126+0x13c>
		// Overrun then request a new payload buffer
		if (!udd_g_ctrlreq.over_under_run) {
   41316:	e0 91 71 29 	lds	r30, 0x2971
   4131a:	f0 91 72 29 	lds	r31, 0x2972
   4131e:	30 97       	sbiw	r30, 0x00	; 0
   41320:	11 f4       	brne	.+4      	; 0x41326 <__vector_126+0x10e>
			// No callback available to request a new payload buffer
			udd_ctrl_stall_data();
   41322:	4f dd       	rcall	.-1378   	; 0x40dc2 <udd_ctrl_stall_data>
   41324:	21 c0       	rjmp	.+66     	; 0x41368 <__vector_126+0x150>
			return;
		}
		if (!udd_g_ctrlreq.over_under_run()) {
   41326:	19 95       	eicall
   41328:	81 11       	cpse	r24, r1
   4132a:	02 c0       	rjmp	.+4      	; 0x41330 <__vector_126+0x118>
			// No new payload buffer delivered
			udd_ctrl_stall_data();
   4132c:	4a dd       	rcall	.-1388   	; 0x40dc2 <udd_ctrl_stall_data>
   4132e:	1c c0       	rjmp	.+56     	; 0x41368 <__vector_126+0x150>
			return;
		}
		// New payload buffer available
		// Update number of total data received
		udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
   41330:	20 91 3f 29 	lds	r18, 0x293F
   41334:	30 91 40 29 	lds	r19, 0x2940
   41338:	80 91 3d 29 	lds	r24, 0x293D
   4133c:	90 91 3e 29 	lds	r25, 0x293E
   41340:	82 0f       	add	r24, r18
   41342:	93 1f       	adc	r25, r19
   41344:	80 93 3f 29 	sts	0x293F, r24
   41348:	90 93 40 29 	sts	0x2940, r25
		// Reinit reception on payload buffer
		udd_ctrl_payload_nb_trans = 0;
   4134c:	10 92 3d 29 	sts	0x293D, r1
   41350:	10 92 3e 29 	sts	0x293E, r1
	}
	// Free buffer of OUT control endpoint to authorize next reception
	udd_control_out_clear_NACK0();
   41354:	e8 e4       	ldi	r30, 0x48	; 72
   41356:	f9 e2       	ldi	r31, 0x29	; 41
   41358:	02 e0       	ldi	r16, 0x02	; 2
   4135a:	06 93       	lac	Z, r16
   4135c:	05 c0       	rjmp	.+10     	; 0x41368 <__vector_126+0x150>
	udd_get_fifo_rp();
	if (udd_endpoint_transfer_complete(udd_ep_get_ctrl(0))) {
		udd_endpoint_ack_transfer_complete(udd_ep_get_ctrl(0));
		udd_ctrl_out_received();
	}else{
		udd_endpoint_ack_transfer_complete(udd_ep_get_ctrl(0 | USB_EP_DIR_IN));
   4135e:	e0 e5       	ldi	r30, 0x50	; 80
   41360:	f9 e2       	ldi	r31, 0x29	; 41
   41362:	00 e2       	ldi	r16, 0x20	; 32
   41364:	06 93       	lac	Z, r16
		udd_ctrl_in_sent();
   41366:	51 dd       	rcall	.-1374   	; 0x40e0a <udd_ctrl_in_sent>
	}
#endif

udd_interrupt_tc_end:
	return;
}
   41368:	ff 91       	pop	r31
   4136a:	ef 91       	pop	r30
   4136c:	df 91       	pop	r29
   4136e:	cf 91       	pop	r28
   41370:	bf 91       	pop	r27
   41372:	af 91       	pop	r26
   41374:	9f 91       	pop	r25
   41376:	8f 91       	pop	r24
   41378:	7f 91       	pop	r23
   4137a:	6f 91       	pop	r22
   4137c:	5f 91       	pop	r21
   4137e:	4f 91       	pop	r20
   41380:	3f 91       	pop	r19
   41382:	2f 91       	pop	r18
   41384:	1f 91       	pop	r17
   41386:	0f 91       	pop	r16
   41388:	0f 90       	pop	r0
   4138a:	0b be       	out	0x3b, r0	; 59
   4138c:	0f 90       	pop	r0
   4138e:	0f be       	out	0x3f, r0	; 63
   41390:	0f 90       	pop	r0
   41392:	1f 90       	pop	r1
   41394:	18 95       	reti

00041396 <mem_flash_write>:
 * \param dst    Pointer to flash destination.
 * \param src    Pointer to source data.
 * \param nbytes Number of bytes to transfer.
 */
static void mem_flash_write(isp_addr_t dst, const void *src, uint16_t nbytes)
{
   41396:	0f 93       	push	r16
   41398:	fb 01       	movw	r30, r22
   4139a:	9a 01       	movw	r18, r20
	nvm_flash_erase_and_write_buffer(dst, src, nbytes, true);
   4139c:	bc 01       	movw	r22, r24
   4139e:	80 e0       	ldi	r24, 0x00	; 0
   413a0:	90 e0       	ldi	r25, 0x00	; 0
   413a2:	01 e0       	ldi	r16, 0x01	; 1
   413a4:	af 01       	movw	r20, r30
   413a6:	1b d2       	rcall	.+1078   	; 0x417de <nvm_flash_erase_and_write_buffer>
}
   413a8:	0f 91       	pop	r16
   413aa:	08 95       	ret

000413ac <mem_flash_read>:
 * \param dst    Pointer to data destination.
 * \param src    Pointer to source flash.
 * \param nbytes Number of bytes to transfer.
 */
static void mem_flash_read(void *dst, isp_addr_t src, uint16_t nbytes)
{
   413ac:	fc 01       	movw	r30, r24
   413ae:	9a 01       	movw	r18, r20
	nvm_flash_read_buffer(src, dst, nbytes);
   413b0:	80 e0       	ldi	r24, 0x00	; 0
   413b2:	90 e0       	ldi	r25, 0x00	; 0
   413b4:	af 01       	movw	r20, r30
   413b6:	fc c1       	rjmp	.+1016   	; 0x417b0 <nvm_flash_read_buffer>
   413b8:	08 95       	ret

000413ba <mem_eeprom_write>:
	while (nbytes--) {
		nvm_eeprom_write_byte(dst++, *(uint8_t*)src);
		src = (uint8_t*)src + 1;
	}
#else
	nvm_eeprom_erase_and_write_buffer(dst, src, nbytes);
   413ba:	8c c1       	rjmp	.+792    	; 0x416d4 <nvm_eeprom_erase_and_write_buffer>
   413bc:	08 95       	ret

000413be <mem_eeprom_read>:
 * \param dst    Pointer to data destination.
 * \param src    Pointer to source flash.
 * \param nbytes Number of bytes to transfer.
 */
static void mem_eeprom_read(void *dst, isp_addr_t src, uint16_t nbytes)
{
   413be:	9c 01       	movw	r18, r24
   413c0:	cb 01       	movw	r24, r22
	nvm_eeprom_read_buffer( src, dst, nbytes );
   413c2:	b9 01       	movw	r22, r18
   413c4:	eb c0       	rjmp	.+470    	; 0x4159c <nvm_eeprom_read_buffer>
   413c6:	08 95       	ret

000413c8 <mem_bootloader_read>:
 * \param src    Pointer to source memory.
 * \param nbytes Number of bytes to transfer.
 */
static void mem_bootloader_read(void *dst, isp_addr_t src, uint16_t nbytes)
{
	memcpy(dst, (uint8_t*)&mem_bootloader + src, nbytes);
   413c8:	64 5a       	subi	r22, 0xA4	; 164
   413ca:	76 4d       	sbci	r23, 0xD6	; 214
   413cc:	81 c3       	rjmp	.+1794   	; 0x41ad0 <memcpy>
   413ce:	08 95       	ret

000413d0 <mem_signature_read>:
 * \param src    Pointer to source memory.
 * \param nbytes Number of bytes to transfer.
 */
static void mem_signature_read(void *dst, isp_addr_t src, uint16_t nbytes)
{
	memcpy(dst, (uint8_t*)&mem_signature + src, nbytes);
   413d0:	61 5a       	subi	r22, 0xA1	; 161
   413d2:	76 4d       	sbci	r23, 0xD6	; 214
   413d4:	7d c3       	rjmp	.+1786   	; 0x41ad0 <memcpy>
   413d6:	08 95       	ret

000413d8 <isp_init>:
 */
//@{

void isp_init(void)
{
	mem_signature.manufacture = MCU.DEVID0;
   413d8:	e0 e9       	ldi	r30, 0x90	; 144
   413da:	f0 e0       	ldi	r31, 0x00	; 0
   413dc:	80 81       	ld	r24, Z
   413de:	80 93 5f 29 	sts	0x295F, r24
	mem_signature.product_number_msb = MCU.DEVID1;
   413e2:	81 81       	ldd	r24, Z+1	; 0x01
   413e4:	80 93 60 29 	sts	0x2960, r24
	mem_signature.product_number_lsb = MCU.DEVID2;
   413e8:	82 81       	ldd	r24, Z+2	; 0x02
   413ea:	80 93 61 29 	sts	0x2961, r24
	mem_signature.product_revision = MCU.REVID;
   413ee:	83 81       	ldd	r24, Z+3	; 0x03
   413f0:	80 93 62 29 	sts	0x2962, r24
   413f4:	08 95       	ret

000413f6 <isp_is_security>:
}


bool isp_is_security(void)
{
	return !(NVM_LOCKBITS&NVM_LOCKBITS_LB1_bm);
   413f6:	80 91 d0 01 	lds	r24, 0x01D0
   413fa:	86 95       	lsr	r24
   413fc:	81 70       	andi	r24, 0x01	; 1
}
   413fe:	91 e0       	ldi	r25, 0x01	; 1
   41400:	89 27       	eor	r24, r25
   41402:	08 95       	ret

00041404 <isp_erase_chip>:
 */
static inline void nvm_wait_until_ready( void )
{
	do {
		// Block execution while waiting for the NVM to be ready
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
   41404:	e0 ec       	ldi	r30, 0xC0	; 192
   41406:	f1 e0       	ldi	r31, 0x01	; 1
   41408:	87 85       	ldd	r24, Z+15	; 0x0f
   4140a:	88 23       	and	r24, r24
   4140c:	ec f3       	brlt	.-6      	; 0x41408 <isp_erase_chip+0x4>
 * Erase all of the application section.
 */
static inline void nvm_flash_erase_app(void)
{
	nvm_wait_until_ready();
	nvm_common_spm(0, NVM_CMD_ERASE_APP_gc);
   4140e:	40 e2       	ldi	r20, 0x20	; 32
   41410:	60 e0       	ldi	r22, 0x00	; 0
   41412:	70 e0       	ldi	r23, 0x00	; 0
   41414:	cb 01       	movw	r24, r22
   41416:	1e 94 20 01 	call	0x40240	; 0x40240 <nvm_common_spm>


bool isp_erase_chip(void)
{
	nvm_flash_erase_app();
	nvm_eeprom_erase_all();
   4141a:	c6 d1       	rcall	.+908    	; 0x417a8 <nvm_eeprom_erase_all>
	return true;
}
   4141c:	81 e0       	ldi	r24, 0x01	; 1
   4141e:	08 95       	ret

00041420 <isp_start_appli>:


void isp_start_appli(void)
{
	cpu_irq_disable();
   41420:	f8 94       	cli
	// generate soft reset for Xmega
	start_app_key=0x55AA;
   41422:	8a ea       	ldi	r24, 0xAA	; 170
   41424:	95 e5       	ldi	r25, 0x55	; 85
   41426:	80 93 73 29 	sts	0x2973, r24
   4142a:	90 93 74 29 	sts	0x2974, r25
	ccp_write_io((uint8_t *)&RST.CTRL, RST.CTRL | RST_SWRST_bm);
   4142e:	e8 e7       	ldi	r30, 0x78	; 120
   41430:	f0 e0       	ldi	r31, 0x00	; 0
   41432:	61 81       	ldd	r22, Z+1	; 0x01
   41434:	61 60       	ori	r22, 0x01	; 1
   41436:	89 e7       	ldi	r24, 0x79	; 121
   41438:	90 e0       	ldi	r25, 0x00	; 0
   4143a:	b6 d2       	rcall	.+1388   	; 0x419a8 <ccp_write_io>
   4143c:	ff cf       	rjmp	.-2      	; 0x4143c <isp_start_appli+0x1c>

0004143e <isp_force_boot_isp>:
	while (1);
}


void isp_force_boot_isp(bool force)
{
   4143e:	08 95       	ret

00041440 <sysclk_init>:
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
   41440:	cf 93       	push	r28
   41442:	df 93       	push	r29
   41444:	00 d0       	rcall	.+0      	; 0x41446 <sysclk_init+0x6>
   41446:	1f 92       	push	r1
   41448:	cd b7       	in	r28, 0x3d	; 61
   4144a:	de b7       	in	r29, 0x3e	; 62
   4144c:	8f ef       	ldi	r24, 0xFF	; 255
   4144e:	80 93 70 00 	sts	0x0070, r24
   41452:	80 93 71 00 	sts	0x0071, r24
   41456:	80 93 72 00 	sts	0x0072, r24
   4145a:	80 93 73 00 	sts	0x0073, r24
   4145e:	80 93 74 00 	sts	0x0074, r24
   41462:	80 93 75 00 	sts	0x0075, r24
   41466:	80 93 76 00 	sts	0x0076, r24
   4146a:	64 e0       	ldi	r22, 0x04	; 4
   4146c:	81 e4       	ldi	r24, 0x41	; 65
   4146e:	90 e0       	ldi	r25, 0x00	; 0
   41470:	9b d2       	rcall	.+1334   	; 0x419a8 <ccp_write_io>
   41472:	6c e1       	ldi	r22, 0x1C	; 28
   41474:	70 e0       	ldi	r23, 0x00	; 0
   41476:	82 e0       	ldi	r24, 0x02	; 2
   41478:	8d d2       	rcall	.+1306   	; 0x41994 <nvm_read_byte>
   4147a:	8a 83       	std	Y+2, r24	; 0x02
   4147c:	6d e1       	ldi	r22, 0x1D	; 29
   4147e:	70 e0       	ldi	r23, 0x00	; 0
   41480:	82 e0       	ldi	r24, 0x02	; 2
   41482:	88 d2       	rcall	.+1296   	; 0x41994 <nvm_read_byte>
   41484:	89 83       	std	Y+1, r24	; 0x01
   41486:	89 81       	ldd	r24, Y+1	; 0x01
   41488:	9a 81       	ldd	r25, Y+2	; 0x02
   4148a:	01 96       	adiw	r24, 0x01	; 1
   4148c:	21 f4       	brne	.+8      	; 0x41496 <sysclk_init+0x56>
   4148e:	80 e4       	ldi	r24, 0x40	; 64
   41490:	93 e2       	ldi	r25, 0x23	; 35
   41492:	89 83       	std	Y+1, r24	; 0x01
   41494:	9a 83       	std	Y+2, r25	; 0x02
   41496:	89 81       	ldd	r24, Y+1	; 0x01
   41498:	9a 81       	ldd	r25, Y+2	; 0x02
   4149a:	8b 83       	std	Y+3, r24	; 0x03
   4149c:	9c 83       	std	Y+4, r25	; 0x04
   4149e:	e0 e6       	ldi	r30, 0x60	; 96
   414a0:	f0 e0       	ldi	r31, 0x00	; 0
   414a2:	82 83       	std	Z+2, r24	; 0x02
   414a4:	8c 81       	ldd	r24, Y+4	; 0x04
   414a6:	83 83       	std	Z+3, r24	; 0x03
   414a8:	8f b7       	in	r24, 0x3f	; 63
   414aa:	f8 94       	cli
   414ac:	e0 e5       	ldi	r30, 0x50	; 80
   414ae:	f0 e0       	ldi	r31, 0x00	; 0
   414b0:	90 81       	ld	r25, Z
   414b2:	92 60       	ori	r25, 0x02	; 2
   414b4:	90 83       	st	Z, r25
   414b6:	8f bf       	out	0x3f, r24	; 63
   414b8:	81 81       	ldd	r24, Z+1	; 0x01
   414ba:	81 ff       	sbrs	r24, 1
   414bc:	fd cf       	rjmp	.-6      	; 0x414b8 <sysclk_init+0x78>
   414be:	8f b7       	in	r24, 0x3f	; 63
   414c0:	f8 94       	cli
   414c2:	a0 e5       	ldi	r26, 0x50	; 80
   414c4:	b0 e0       	ldi	r27, 0x00	; 0
   414c6:	16 96       	adiw	r26, 0x06	; 6
   414c8:	9c 91       	ld	r25, X
   414ca:	16 97       	sbiw	r26, 0x06	; 6
   414cc:	99 7f       	andi	r25, 0xF9	; 249
   414ce:	16 96       	adiw	r26, 0x06	; 6
   414d0:	9c 93       	st	X, r25
   414d2:	16 97       	sbiw	r26, 0x06	; 6
   414d4:	e0 e6       	ldi	r30, 0x60	; 96
   414d6:	f0 e0       	ldi	r31, 0x00	; 0
   414d8:	90 e8       	ldi	r25, 0x80	; 128
   414da:	95 83       	std	Z+5, r25	; 0x05
   414dc:	9b eb       	ldi	r25, 0xBB	; 187
   414de:	96 83       	std	Z+6, r25	; 0x06
   414e0:	16 96       	adiw	r26, 0x06	; 6
   414e2:	9c 91       	ld	r25, X
   414e4:	16 97       	sbiw	r26, 0x06	; 6
   414e6:	94 60       	ori	r25, 0x04	; 4
   414e8:	16 96       	adiw	r26, 0x06	; 6
   414ea:	9c 93       	st	X, r25
   414ec:	90 81       	ld	r25, Z
   414ee:	91 60       	ori	r25, 0x01	; 1
   414f0:	90 83       	st	Z, r25
   414f2:	8f bf       	out	0x3f, r24	; 63
   414f4:	61 e0       	ldi	r22, 0x01	; 1
   414f6:	80 e4       	ldi	r24, 0x40	; 64
   414f8:	90 e0       	ldi	r25, 0x00	; 0
   414fa:	56 d2       	rcall	.+1196   	; 0x419a8 <ccp_write_io>
   414fc:	8f b7       	in	r24, 0x3f	; 63
   414fe:	f8 94       	cli
   41500:	e0 e5       	ldi	r30, 0x50	; 80
   41502:	f0 e0       	ldi	r31, 0x00	; 0
   41504:	90 81       	ld	r25, Z
   41506:	9e 7f       	andi	r25, 0xFE	; 254
   41508:	90 83       	st	Z, r25
   4150a:	8f bf       	out	0x3f, r24	; 63
   4150c:	24 96       	adiw	r28, 0x04	; 4
   4150e:	cd bf       	out	0x3d, r28	; 61
   41510:	de bf       	out	0x3e, r29	; 62
   41512:	df 91       	pop	r29
   41514:	cf 91       	pop	r28
   41516:	08 95       	ret

00041518 <sysclk_enable_module>:
   41518:	9f b7       	in	r25, 0x3f	; 63
   4151a:	f8 94       	cli
   4151c:	e8 2f       	mov	r30, r24
   4151e:	f0 e0       	ldi	r31, 0x00	; 0
   41520:	e0 59       	subi	r30, 0x90	; 144
   41522:	ff 4f       	sbci	r31, 0xFF	; 255
   41524:	60 95       	com	r22
   41526:	80 81       	ld	r24, Z
   41528:	68 23       	and	r22, r24
   4152a:	60 83       	st	Z, r22
   4152c:	9f bf       	out	0x3f, r25	; 63
   4152e:	08 95       	ret

00041530 <sysclk_enable_usb>:

	/*
	 * Enable or disable prescaler depending on if the USB frequency is 6
	 * MHz or 48 MHz. Only 6 MHz USB frequency requires prescaling.
	 */
	if (frequency == 6) {
   41530:	86 30       	cpi	r24, 0x06	; 6
   41532:	11 f4       	brne	.+4      	; 0x41538 <sysclk_enable_usb+0x8>
		prescaler = CLK_USBPSDIV_8_gc;
   41534:	68 e1       	ldi	r22, 0x18	; 24
   41536:	01 c0       	rjmp	.+2      	; 0x4153a <sysclk_enable_usb+0xa>
	}
	else {
		prescaler = 0;
   41538:	60 e0       	ldi	r22, 0x00	; 0

static inline bool osc_is_ready(uint8_t id)
{
	Assert(id != OSC_ID_USBSOF);

	return OSC.STATUS & id;
   4153a:	e0 e5       	ldi	r30, 0x50	; 80
   4153c:	f0 e0       	ldi	r31, 0x00	; 0
   4153e:	81 81       	ldd	r24, Z+1	; 0x01
	/*
	 * Switch to the system clock selected by the user.
	 */
	switch (CONFIG_USBCLK_SOURCE) {
	case USBCLK_SRC_RCOSC:
		if (!osc_is_ready(OSC_ID_RC32MHZ)) {
   41540:	81 fd       	sbrc	r24, 1
   41542:	24 c0       	rjmp	.+72     	; 0x4158c <sysclk_enable_usb+0x5c>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
   41544:	8f b7       	in	r24, 0x3f	; 63
	cpu_irq_disable();
   41546:	f8 94       	cli
	irqflags_t flags;

	Assert(id != OSC_ID_USBSOF);

	flags = cpu_irq_save();
	OSC.CTRL |= id;
   41548:	90 81       	ld	r25, Z
   4154a:	92 60       	ori	r25, 0x02	; 2
   4154c:	90 83       	st	Z, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
   4154e:	8f bf       	out	0x3f, r24	; 63

static inline bool osc_is_ready(uint8_t id)
{
	Assert(id != OSC_ID_USBSOF);

	return OSC.STATUS & id;
   41550:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
   41552:	81 ff       	sbrs	r24, 1
   41554:	fd cf       	rjmp	.-6      	; 0x41550 <sysclk_enable_usb+0x20>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
   41556:	8f b7       	in	r24, 0x3f	; 63
	cpu_irq_disable();
   41558:	f8 94       	cli
# if !XMEGA_E
				|| (ref_id == OSC_ID_USBSOF)
#endif
				);

		OSC.DFLLCTRL &= ~(OSC_RC32MCREF_gm);
   4155a:	a0 e5       	ldi	r26, 0x50	; 80
   4155c:	b0 e0       	ldi	r27, 0x00	; 0
   4155e:	16 96       	adiw	r26, 0x06	; 6
   41560:	9c 91       	ld	r25, X
   41562:	16 97       	sbiw	r26, 0x06	; 6
   41564:	99 7f       	andi	r25, 0xF9	; 249
   41566:	16 96       	adiw	r26, 0x06	; 6
   41568:	9c 93       	st	X, r25
   4156a:	16 97       	sbiw	r26, 0x06	; 6
		else if (ref_id == OSC_ID_USBSOF) {
			/*
			 * Calibrate 32MRC at 48MHz using USB SOF
			 * 48MHz / 1kHz = 0xBB80
			 */
			DFLLRC32M.COMP1 = 0x80;
   4156c:	e0 e6       	ldi	r30, 0x60	; 96
   4156e:	f0 e0       	ldi	r31, 0x00	; 0
   41570:	90 e8       	ldi	r25, 0x80	; 128
   41572:	95 83       	std	Z+5, r25	; 0x05
			DFLLRC32M.COMP2 = 0xBB;
   41574:	9b eb       	ldi	r25, 0xBB	; 187
   41576:	96 83       	std	Z+6, r25	; 0x06
			OSC.DFLLCTRL |= OSC_RC32MCREF_USBSOF_gc;
   41578:	16 96       	adiw	r26, 0x06	; 6
   4157a:	9c 91       	ld	r25, X
   4157c:	16 97       	sbiw	r26, 0x06	; 6
   4157e:	94 60       	ori	r25, 0x04	; 4
   41580:	16 96       	adiw	r26, 0x06	; 6
   41582:	9c 93       	st	X, r25
			OSC.DFLLCTRL &= ~(OSC_RC32MCREF_bm);
# endif
		}
#endif

		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
   41584:	90 81       	ld	r25, Z
   41586:	91 60       	ori	r25, 0x01	; 1
   41588:	90 83       	st	Z, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
   4158a:	8f bf       	out	0x3f, r24	; 63
			}
			osc_enable_autocalibration(OSC_ID_RC32MHZ,
					CONFIG_OSC_AUTOCAL_RC32MHZ_REF_OSC);
#endif
		}
		ccp_write_io((uint8_t *)&CLK.USBCTRL, (prescaler)
   4158c:	63 60       	ori	r22, 0x03	; 3
   4158e:	84 e4       	ldi	r24, 0x44	; 68
   41590:	90 e0       	ldi	r25, 0x00	; 0
   41592:	0a d2       	rcall	.+1044   	; 0x419a8 <ccp_write_io>
	default:
		Assert(false);
		break;
	}

	sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_USB);
   41594:	60 e4       	ldi	r22, 0x40	; 64
   41596:	80 e0       	ldi	r24, 0x00	; 0
   41598:	bf cf       	rjmp	.-130    	; 0x41518 <sysclk_enable_module>
   4159a:	08 95       	ret

0004159c <nvm_eeprom_read_buffer>:
	// Write flash buffer
	if (b_flag_erase) {
		nvm_flash_erase_user_section();
	}
	nvm_flash_write_user_page();
}
   4159c:	cf 93       	push	r28
   4159e:	df 93       	push	r29
   415a0:	9b 01       	movw	r18, r22
   415a2:	e0 ec       	ldi	r30, 0xC0	; 192
   415a4:	f1 e0       	ldi	r31, 0x01	; 1
   415a6:	67 85       	ldd	r22, Z+15	; 0x0f
   415a8:	66 23       	and	r22, r22
   415aa:	ec f3       	brlt	.-6      	; 0x415a6 <nvm_eeprom_read_buffer+0xa>
   415ac:	cc ec       	ldi	r28, 0xCC	; 204
   415ae:	d1 e0       	ldi	r29, 0x01	; 1
   415b0:	68 81       	ld	r22, Y
   415b2:	68 60       	ori	r22, 0x08	; 8
   415b4:	68 83       	st	Y, r22
   415b6:	bc 01       	movw	r22, r24
   415b8:	70 5f       	subi	r23, 0xF0	; 240
   415ba:	c9 01       	movw	r24, r18
   415bc:	89 d2       	rcall	.+1298   	; 0x41ad0 <memcpy>
   415be:	88 81       	ld	r24, Y
   415c0:	87 7f       	andi	r24, 0xF7	; 247
   415c2:	88 83       	st	Y, r24
   415c4:	df 91       	pop	r29
   415c6:	cf 91       	pop	r28
   415c8:	08 95       	ret

000415ca <nvm_eeprom_flush_buffer>:
   415ca:	e0 ec       	ldi	r30, 0xC0	; 192
   415cc:	f1 e0       	ldi	r31, 0x01	; 1
   415ce:	87 85       	ldd	r24, Z+15	; 0x0f
   415d0:	88 23       	and	r24, r24
   415d2:	ec f3       	brlt	.-6      	; 0x415ce <nvm_eeprom_flush_buffer+0x4>
   415d4:	e0 ec       	ldi	r30, 0xC0	; 192
   415d6:	f1 e0       	ldi	r31, 0x01	; 1
   415d8:	87 85       	ldd	r24, Z+15	; 0x0f
   415da:	81 ff       	sbrs	r24, 1
   415dc:	06 c0       	rjmp	.+12     	; 0x415ea <nvm_eeprom_flush_buffer+0x20>
   415de:	86 e3       	ldi	r24, 0x36	; 54
   415e0:	82 87       	std	Z+10, r24	; 0x0a
   415e2:	61 e0       	ldi	r22, 0x01	; 1
   415e4:	8b ec       	ldi	r24, 0xCB	; 203
   415e6:	91 e0       	ldi	r25, 0x01	; 1
   415e8:	df c1       	rjmp	.+958    	; 0x419a8 <ccp_write_io>
   415ea:	08 95       	ret

000415ec <nvm_eeprom_load_byte_to_buffer>:
   415ec:	e0 ec       	ldi	r30, 0xC0	; 192
   415ee:	f1 e0       	ldi	r31, 0x01	; 1
   415f0:	97 85       	ldd	r25, Z+15	; 0x0f
   415f2:	99 23       	and	r25, r25
   415f4:	ec f3       	brlt	.-6      	; 0x415f0 <nvm_eeprom_load_byte_to_buffer+0x4>
   415f6:	ec ec       	ldi	r30, 0xCC	; 204
   415f8:	f1 e0       	ldi	r31, 0x01	; 1
   415fa:	90 81       	ld	r25, Z
   415fc:	98 60       	ori	r25, 0x08	; 8
   415fe:	90 83       	st	Z, r25
   41600:	a8 2f       	mov	r26, r24
   41602:	b0 e0       	ldi	r27, 0x00	; 0
   41604:	b0 5f       	subi	r27, 0xF0	; 240
   41606:	6c 93       	st	X, r22
   41608:	80 81       	ld	r24, Z
   4160a:	87 7f       	andi	r24, 0xF7	; 247
   4160c:	80 83       	st	Z, r24
   4160e:	08 95       	ret

00041610 <nvm_eeprom_write_byte>:
   41610:	ff 92       	push	r15
   41612:	0f 93       	push	r16
   41614:	1f 93       	push	r17
   41616:	cf 93       	push	r28
   41618:	df 93       	push	r29
   4161a:	18 2f       	mov	r17, r24
   4161c:	f9 2e       	mov	r15, r25
   4161e:	c6 2f       	mov	r28, r22
   41620:	e0 ec       	ldi	r30, 0xC0	; 192
   41622:	f1 e0       	ldi	r31, 0x01	; 1
   41624:	02 85       	ldd	r16, Z+10	; 0x0a
   41626:	d1 df       	rcall	.-94     	; 0x415ca <nvm_eeprom_flush_buffer>
   41628:	e0 ec       	ldi	r30, 0xC0	; 192
   4162a:	f1 e0       	ldi	r31, 0x01	; 1
   4162c:	27 85       	ldd	r18, Z+15	; 0x0f
   4162e:	22 23       	and	r18, r18
   41630:	ec f3       	brlt	.-6      	; 0x4162c <nvm_eeprom_write_byte+0x1c>
   41632:	6c 2f       	mov	r22, r28
   41634:	81 2f       	mov	r24, r17
   41636:	da df       	rcall	.-76     	; 0x415ec <nvm_eeprom_load_byte_to_buffer>
   41638:	c0 ec       	ldi	r28, 0xC0	; 192
   4163a:	d1 e0       	ldi	r29, 0x01	; 1
   4163c:	1a 82       	std	Y+2, r1	; 0x02
   4163e:	f9 82       	std	Y+1, r15	; 0x01
   41640:	18 83       	st	Y, r17
   41642:	85 e3       	ldi	r24, 0x35	; 53
   41644:	8a 87       	std	Y+10, r24	; 0x0a
   41646:	61 e0       	ldi	r22, 0x01	; 1
   41648:	8b ec       	ldi	r24, 0xCB	; 203
   4164a:	91 e0       	ldi	r25, 0x01	; 1
   4164c:	ad d1       	rcall	.+858    	; 0x419a8 <ccp_write_io>
   4164e:	0a 87       	std	Y+10, r16	; 0x0a
   41650:	df 91       	pop	r29
   41652:	cf 91       	pop	r28
   41654:	1f 91       	pop	r17
   41656:	0f 91       	pop	r16
   41658:	ff 90       	pop	r15
   4165a:	08 95       	ret

0004165c <nvm_eeprom_load_page_to_buffer>:
   4165c:	ef 92       	push	r14
   4165e:	ff 92       	push	r15
   41660:	0f 93       	push	r16
   41662:	1f 93       	push	r17
   41664:	cf 93       	push	r28
   41666:	df 93       	push	r29
   41668:	8c 01       	movw	r16, r24
   4166a:	e0 ec       	ldi	r30, 0xC0	; 192
   4166c:	f1 e0       	ldi	r31, 0x01	; 1
   4166e:	87 85       	ldd	r24, Z+15	; 0x0f
   41670:	88 23       	and	r24, r24
   41672:	ec f3       	brlt	.-6      	; 0x4166e <nvm_eeprom_load_page_to_buffer+0x12>
   41674:	78 01       	movw	r14, r16
   41676:	80 e2       	ldi	r24, 0x20	; 32
   41678:	e8 0e       	add	r14, r24
   4167a:	f1 1c       	adc	r15, r1
   4167c:	e8 01       	movw	r28, r16
   4167e:	8c 2f       	mov	r24, r28
   41680:	80 1b       	sub	r24, r16
   41682:	69 91       	ld	r22, Y+
   41684:	b3 df       	rcall	.-154    	; 0x415ec <nvm_eeprom_load_byte_to_buffer>
   41686:	ce 15       	cp	r28, r14
   41688:	df 05       	cpc	r29, r15
   4168a:	c9 f7       	brne	.-14     	; 0x4167e <nvm_eeprom_load_page_to_buffer+0x22>
   4168c:	df 91       	pop	r29
   4168e:	cf 91       	pop	r28
   41690:	1f 91       	pop	r17
   41692:	0f 91       	pop	r16
   41694:	ff 90       	pop	r15
   41696:	ef 90       	pop	r14
   41698:	08 95       	ret

0004169a <nvm_eeprom_atomic_write_page>:
   4169a:	1f 93       	push	r17
   4169c:	cf 93       	push	r28
   4169e:	df 93       	push	r29
   416a0:	e0 ec       	ldi	r30, 0xC0	; 192
   416a2:	f1 e0       	ldi	r31, 0x01	; 1
   416a4:	97 85       	ldd	r25, Z+15	; 0x0f
   416a6:	99 23       	and	r25, r25
   416a8:	ec f3       	brlt	.-6      	; 0x416a4 <nvm_eeprom_atomic_write_page+0xa>
   416aa:	20 e2       	ldi	r18, 0x20	; 32
   416ac:	82 9f       	mul	r24, r18
   416ae:	c0 01       	movw	r24, r0
   416b0:	11 24       	eor	r1, r1
   416b2:	c0 ec       	ldi	r28, 0xC0	; 192
   416b4:	d1 e0       	ldi	r29, 0x01	; 1
   416b6:	1a 82       	std	Y+2, r1	; 0x02
   416b8:	99 83       	std	Y+1, r25	; 0x01
   416ba:	88 83       	st	Y, r24
   416bc:	1a 85       	ldd	r17, Y+10	; 0x0a
   416be:	85 e3       	ldi	r24, 0x35	; 53
   416c0:	8a 87       	std	Y+10, r24	; 0x0a
   416c2:	61 e0       	ldi	r22, 0x01	; 1
   416c4:	8b ec       	ldi	r24, 0xCB	; 203
   416c6:	91 e0       	ldi	r25, 0x01	; 1
   416c8:	6f d1       	rcall	.+734    	; 0x419a8 <ccp_write_io>
   416ca:	1a 87       	std	Y+10, r17	; 0x0a
   416cc:	df 91       	pop	r29
   416ce:	cf 91       	pop	r28
   416d0:	1f 91       	pop	r17
   416d2:	08 95       	ret

000416d4 <nvm_eeprom_erase_and_write_buffer>:
   416d4:	cf 92       	push	r12
   416d6:	df 92       	push	r13
   416d8:	ef 92       	push	r14
   416da:	ff 92       	push	r15
   416dc:	0f 93       	push	r16
   416de:	1f 93       	push	r17
   416e0:	cf 93       	push	r28
   416e2:	df 93       	push	r29
   416e4:	ec 01       	movw	r28, r24
   416e6:	7b 01       	movw	r14, r22
   416e8:	8a 01       	movw	r16, r20
   416ea:	41 15       	cp	r20, r1
   416ec:	51 05       	cpc	r21, r1
   416ee:	51 f1       	breq	.+84     	; 0x41744 <nvm_eeprom_erase_and_write_buffer+0x70>
   416f0:	ce 01       	movw	r24, r28
   416f2:	8f 71       	andi	r24, 0x1F	; 31
   416f4:	99 27       	eor	r25, r25
   416f6:	89 2b       	or	r24, r25
   416f8:	b1 f4       	brne	.+44     	; 0x41726 <nvm_eeprom_erase_and_write_buffer+0x52>
   416fa:	00 32       	cpi	r16, 0x20	; 32
   416fc:	11 05       	cpc	r17, r1
   416fe:	98 f0       	brcs	.+38     	; 0x41726 <nvm_eeprom_erase_and_write_buffer+0x52>
   41700:	c7 01       	movw	r24, r14
   41702:	ac df       	rcall	.-168    	; 0x4165c <nvm_eeprom_load_page_to_buffer>
   41704:	ce 01       	movw	r24, r28
   41706:	96 95       	lsr	r25
   41708:	87 95       	ror	r24
   4170a:	92 95       	swap	r25
   4170c:	82 95       	swap	r24
   4170e:	8f 70       	andi	r24, 0x0F	; 15
   41710:	89 27       	eor	r24, r25
   41712:	9f 70       	andi	r25, 0x0F	; 15
   41714:	89 27       	eor	r24, r25
   41716:	c1 df       	rcall	.-126    	; 0x4169a <nvm_eeprom_atomic_write_page>
   41718:	a0 96       	adiw	r28, 0x20	; 32
   4171a:	80 e2       	ldi	r24, 0x20	; 32
   4171c:	e8 0e       	add	r14, r24
   4171e:	f1 1c       	adc	r15, r1
   41720:	00 52       	subi	r16, 0x20	; 32
   41722:	11 09       	sbc	r17, r1
   41724:	0c c0       	rjmp	.+24     	; 0x4173e <nvm_eeprom_erase_and_write_buffer+0x6a>
   41726:	6e 01       	movw	r12, r28
   41728:	ef ef       	ldi	r30, 0xFF	; 255
   4172a:	ce 1a       	sub	r12, r30
   4172c:	de 0a       	sbc	r13, r30
   4172e:	f7 01       	movw	r30, r14
   41730:	61 91       	ld	r22, Z+
   41732:	7f 01       	movw	r14, r30
   41734:	ce 01       	movw	r24, r28
   41736:	6c df       	rcall	.-296    	; 0x41610 <nvm_eeprom_write_byte>
   41738:	01 50       	subi	r16, 0x01	; 1
   4173a:	11 09       	sbc	r17, r1
   4173c:	e6 01       	movw	r28, r12
   4173e:	01 15       	cp	r16, r1
   41740:	11 05       	cpc	r17, r1
   41742:	b1 f6       	brne	.-84     	; 0x416f0 <nvm_eeprom_erase_and_write_buffer+0x1c>
   41744:	df 91       	pop	r29
   41746:	cf 91       	pop	r28
   41748:	1f 91       	pop	r17
   4174a:	0f 91       	pop	r16
   4174c:	ff 90       	pop	r15
   4174e:	ef 90       	pop	r14
   41750:	df 90       	pop	r13
   41752:	cf 90       	pop	r12
   41754:	08 95       	ret

00041756 <nvm_eeprom_fill_buffer_with_value>:
   41756:	cf 93       	push	r28
   41758:	df 93       	push	r29
   4175a:	d8 2f       	mov	r29, r24
   4175c:	36 df       	rcall	.-404    	; 0x415ca <nvm_eeprom_flush_buffer>
   4175e:	e0 ec       	ldi	r30, 0xC0	; 192
   41760:	f1 e0       	ldi	r31, 0x01	; 1
   41762:	87 85       	ldd	r24, Z+15	; 0x0f
   41764:	88 23       	and	r24, r24
   41766:	ec f3       	brlt	.-6      	; 0x41762 <nvm_eeprom_fill_buffer_with_value+0xc>
   41768:	c0 e0       	ldi	r28, 0x00	; 0
   4176a:	6d 2f       	mov	r22, r29
   4176c:	8c 2f       	mov	r24, r28
   4176e:	3e df       	rcall	.-388    	; 0x415ec <nvm_eeprom_load_byte_to_buffer>
   41770:	cf 5f       	subi	r28, 0xFF	; 255
   41772:	c0 32       	cpi	r28, 0x20	; 32
   41774:	d1 f7       	brne	.-12     	; 0x4176a <nvm_eeprom_fill_buffer_with_value+0x14>
   41776:	df 91       	pop	r29
   41778:	cf 91       	pop	r28
   4177a:	08 95       	ret

0004177c <nvm_eeprom_erase_bytes_in_all_pages>:
   4177c:	1f 93       	push	r17
   4177e:	cf 93       	push	r28
   41780:	df 93       	push	r29
   41782:	e0 ec       	ldi	r30, 0xC0	; 192
   41784:	f1 e0       	ldi	r31, 0x01	; 1
   41786:	87 85       	ldd	r24, Z+15	; 0x0f
   41788:	88 23       	and	r24, r24
   4178a:	ec f3       	brlt	.-6      	; 0x41786 <nvm_eeprom_erase_bytes_in_all_pages+0xa>
   4178c:	c0 ec       	ldi	r28, 0xC0	; 192
   4178e:	d1 e0       	ldi	r29, 0x01	; 1
   41790:	1a 85       	ldd	r17, Y+10	; 0x0a
   41792:	80 e3       	ldi	r24, 0x30	; 48
   41794:	8a 87       	std	Y+10, r24	; 0x0a
   41796:	61 e0       	ldi	r22, 0x01	; 1
   41798:	8b ec       	ldi	r24, 0xCB	; 203
   4179a:	91 e0       	ldi	r25, 0x01	; 1
   4179c:	05 d1       	rcall	.+522    	; 0x419a8 <ccp_write_io>
   4179e:	1a 87       	std	Y+10, r17	; 0x0a
   417a0:	df 91       	pop	r29
   417a2:	cf 91       	pop	r28
   417a4:	1f 91       	pop	r17
   417a6:	08 95       	ret

000417a8 <nvm_eeprom_erase_all>:
   417a8:	8f ef       	ldi	r24, 0xFF	; 255
   417aa:	d5 df       	rcall	.-86     	; 0x41756 <nvm_eeprom_fill_buffer_with_value>
   417ac:	e7 cf       	rjmp	.-50     	; 0x4177c <nvm_eeprom_erase_bytes_in_all_pages>
   417ae:	08 95       	ret

000417b0 <nvm_flash_read_buffer>:
   417b0:	da 01       	movw	r26, r20
   417b2:	e0 ec       	ldi	r30, 0xC0	; 192
   417b4:	f1 e0       	ldi	r31, 0x01	; 1
   417b6:	47 85       	ldd	r20, Z+15	; 0x0f
   417b8:	44 23       	and	r20, r20
   417ba:	ec f3       	brlt	.-6      	; 0x417b6 <nvm_flash_read_buffer+0x6>
   417bc:	21 15       	cp	r18, r1
   417be:	31 05       	cpc	r19, r1
   417c0:	69 f0       	breq	.+26     	; 0x417dc <nvm_flash_read_buffer+0x2c>
   417c2:	2a 0f       	add	r18, r26
   417c4:	3b 1f       	adc	r19, r27
   417c6:	8b bf       	out	0x3b, r24	; 59
   417c8:	fb 01       	movw	r30, r22
   417ca:	47 91       	elpm	r20, Z+
   417cc:	4d 93       	st	X+, r20
   417ce:	6f 5f       	subi	r22, 0xFF	; 255
   417d0:	7f 4f       	sbci	r23, 0xFF	; 255
   417d2:	8f 4f       	sbci	r24, 0xFF	; 255
   417d4:	9f 4f       	sbci	r25, 0xFF	; 255
   417d6:	a2 17       	cp	r26, r18
   417d8:	b3 07       	cpc	r27, r19
   417da:	a9 f7       	brne	.-22     	; 0x417c6 <nvm_flash_read_buffer+0x16>
   417dc:	08 95       	ret

000417de <nvm_flash_erase_and_write_buffer>:
 *
 * Set b_blank_check to false if all application flash is erased before.
 */
void nvm_flash_erase_and_write_buffer(flash_addr_t address, const void *buf,
	uint16_t len, bool b_blank_check)
{
   417de:	2f 92       	push	r2
   417e0:	3f 92       	push	r3
   417e2:	4f 92       	push	r4
   417e4:	5f 92       	push	r5
   417e6:	6f 92       	push	r6
   417e8:	7f 92       	push	r7
   417ea:	8f 92       	push	r8
   417ec:	9f 92       	push	r9
   417ee:	af 92       	push	r10
   417f0:	bf 92       	push	r11
   417f2:	cf 92       	push	r12
   417f4:	df 92       	push	r13
   417f6:	ef 92       	push	r14
   417f8:	ff 92       	push	r15
   417fa:	0f 93       	push	r16
   417fc:	1f 93       	push	r17
   417fe:	cf 93       	push	r28
   41800:	df 93       	push	r29
   41802:	cd b7       	in	r28, 0x3d	; 61
   41804:	de b7       	in	r29, 0x3e	; 62
   41806:	2e 97       	sbiw	r28, 0x0e	; 14
   41808:	cd bf       	out	0x3d, r28	; 61
   4180a:	de bf       	out	0x3e, r29	; 62
   4180c:	2b 01       	movw	r4, r22
   4180e:	3c 01       	movw	r6, r24
   41810:	1a 01       	movw	r2, r20
   41812:	59 01       	movw	r10, r18
	uint16_t page_address;
	uint16_t opt_address = (uint16_t)address;
#endif

	// Compute the start of the page to be modified
	page_address = opt_address-(opt_address%FLASH_PAGE_SIZE);
   41814:	dc 01       	movw	r26, r24
   41816:	cb 01       	movw	r24, r22
   41818:	88 27       	eor	r24, r24
   4181a:	9e 7f       	andi	r25, 0xFE	; 254
   4181c:	8f 83       	std	Y+7, r24	; 0x07
   4181e:	98 87       	std	Y+8, r25	; 0x08
   41820:	a9 87       	std	Y+9, r26	; 0x09
   41822:	ba 87       	std	Y+10, r27	; 0x0a

	// For each page
	while ( len ) {
   41824:	21 15       	cp	r18, r1
   41826:	31 05       	cpc	r19, r1
   41828:	09 f4       	brne	.+2      	; 0x4182c <nvm_flash_erase_and_write_buffer+0x4e>
   4182a:	9e c0       	rjmp	.+316    	; 0x41968 <nvm_flash_erase_and_write_buffer+0x18a>
				w_value = nvm_flash_read_word(page_address);
				if (w_value!=0xFFFF) {
					b_flag_erase = true; // The page is not empty
				}
			}else{
				w_value = 0xFFFF;
   4182c:	88 24       	eor	r8, r8
   4182e:	8a 94       	dec	r8
   41830:	98 2c       	mov	r9, r8
   41832:	4b 86       	std	Y+11, r4	; 0x0b
   41834:	5c 86       	std	Y+12, r5	; 0x0c
   41836:	6d 86       	std	Y+13, r6	; 0x0d
   41838:	7e 86       	std	Y+14, r7	; 0x0e
 */
static inline void nvm_wait_until_ready( void )
{
	do {
		// Block execution while waiting for the NVM to be ready
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
   4183a:	80 91 cf 01 	lds	r24, 0x01CF
   4183e:	88 23       	and	r24, r24
   41840:	e4 f3       	brlt	.-8      	; 0x4183a <nvm_flash_erase_and_write_buffer+0x5c>
   41842:	8f 81       	ldd	r24, Y+7	; 0x07
   41844:	98 85       	ldd	r25, Y+8	; 0x08
   41846:	a9 85       	ldd	r26, Y+9	; 0x09
   41848:	ba 85       	ldd	r27, Y+10	; 0x0a
   4184a:	9e 5f       	subi	r25, 0xFE	; 254
   4184c:	af 4f       	sbci	r26, 0xFF	; 255
   4184e:	bf 4f       	sbci	r27, 0xFF	; 255
   41850:	8b 83       	std	Y+3, r24	; 0x03
   41852:	9c 83       	std	Y+4, r25	; 0x04
   41854:	ad 83       	std	Y+5, r26	; 0x05
   41856:	be 83       	std	Y+6, r27	; 0x06
   41858:	cf 80       	ldd	r12, Y+7	; 0x07
   4185a:	d8 84       	ldd	r13, Y+8	; 0x08
   4185c:	e9 84       	ldd	r14, Y+9	; 0x09
   4185e:	fa 84       	ldd	r15, Y+10	; 0x0a
   41860:	10 e0       	ldi	r17, 0x00	; 0
   41862:	26 01       	movw	r4, r12
   41864:	37 01       	movw	r6, r14
   41866:	75 01       	movw	r14, r10
   41868:	ab 84       	ldd	r10, Y+11	; 0x0b
   4186a:	bc 84       	ldd	r11, Y+12	; 0x0c
   4186c:	cd 84       	ldd	r12, Y+13	; 0x0d
   4186e:	de 84       	ldd	r13, Y+14	; 0x0e
	while ( len ) {
		b_flag_erase = false;

		nvm_wait_until_ready();
		for (page_pos=0; page_pos<FLASH_PAGE_SIZE; page_pos+=2 ) {
			if (b_blank_check) {
   41870:	00 23       	and	r16, r16
   41872:	49 f0       	breq	.+18     	; 0x41886 <nvm_flash_erase_and_write_buffer+0xa8>
 * \return Word from program memory
 */
static inline uint16_t nvm_flash_read_word(flash_addr_t addr)
{
#if defined(__GNUC__)
	return pgm_read_word_far(addr);
   41874:	6b be       	out	0x3b, r6	; 59
   41876:	f2 01       	movw	r30, r4
   41878:	87 91       	elpm	r24, Z+
   4187a:	96 91       	elpm	r25, Z
				// Read flash to know if the erase command is mandatory
				w_value = nvm_flash_read_word(page_address);
   4187c:	89 83       	std	Y+1, r24	; 0x01
   4187e:	9a 83       	std	Y+2, r25	; 0x02
				if (w_value!=0xFFFF) {
   41880:	01 96       	adiw	r24, 0x01	; 1
   41882:	21 f4       	brne	.+8      	; 0x4188c <nvm_flash_erase_and_write_buffer+0xae>
   41884:	04 c0       	rjmp	.+8      	; 0x4188e <nvm_flash_erase_and_write_buffer+0xb0>
					b_flag_erase = true; // The page is not empty
				}
			}else{
				w_value = 0xFFFF;
   41886:	89 82       	std	Y+1, r8	; 0x01
   41888:	9a 82       	std	Y+2, r9	; 0x02
   4188a:	01 c0       	rjmp	.+2      	; 0x4188e <nvm_flash_erase_and_write_buffer+0xb0>
		for (page_pos=0; page_pos<FLASH_PAGE_SIZE; page_pos+=2 ) {
			if (b_blank_check) {
				// Read flash to know if the erase command is mandatory
				w_value = nvm_flash_read_word(page_address);
				if (w_value!=0xFFFF) {
					b_flag_erase = true; // The page is not empty
   4188c:	11 e0       	ldi	r17, 0x01	; 1
			}else{
				w_value = 0xFFFF;
			}

			// Update flash buffer
			if (len) {
   4188e:	e1 14       	cp	r14, r1
   41890:	f1 04       	cpc	r15, r1
   41892:	69 f1       	breq	.+90     	; 0x418ee <nvm_flash_erase_and_write_buffer+0x110>
				if (opt_address == page_address) {
   41894:	a4 14       	cp	r10, r4
   41896:	b5 04       	cpc	r11, r5
   41898:	c6 04       	cpc	r12, r6
   4189a:	d7 04       	cpc	r13, r7
   4189c:	81 f4       	brne	.+32     	; 0x418be <nvm_flash_erase_and_write_buffer+0xe0>
					// The MSB of flash word must be changed
					// because the address is even
					len--;
   4189e:	b1 e0       	ldi	r27, 0x01	; 1
   418a0:	eb 1a       	sub	r14, r27
   418a2:	f1 08       	sbc	r15, r1
					opt_address++;
   418a4:	ef ef       	ldi	r30, 0xFF	; 255
   418a6:	ae 1a       	sub	r10, r30
   418a8:	be 0a       	sbc	r11, r30
   418aa:	ce 0a       	sbc	r12, r30
   418ac:	de 0a       	sbc	r13, r30
					LSB(w_value)=*(uint8_t*)buf;
   418ae:	d1 01       	movw	r26, r2
   418b0:	8d 91       	ld	r24, X+
   418b2:	1d 01       	movw	r2, r26
   418b4:	89 83       	std	Y+1, r24	; 0x01
					buf=(uint8_t*)buf+1;
				}
			}
			if (len) {
   418b6:	e1 14       	cp	r14, r1
   418b8:	f1 04       	cpc	r15, r1
   418ba:	59 f4       	brne	.+22     	; 0x418d2 <nvm_flash_erase_and_write_buffer+0xf4>
   418bc:	18 c0       	rjmp	.+48     	; 0x418ee <nvm_flash_erase_and_write_buffer+0x110>
   418be:	d3 01       	movw	r26, r6
   418c0:	c2 01       	movw	r24, r4
   418c2:	01 96       	adiw	r24, 0x01	; 1
   418c4:	a1 1d       	adc	r26, r1
   418c6:	b1 1d       	adc	r27, r1
				if (opt_address == (page_address+1)) {
   418c8:	8a 15       	cp	r24, r10
   418ca:	9b 05       	cpc	r25, r11
   418cc:	ac 05       	cpc	r26, r12
   418ce:	bd 05       	cpc	r27, r13
   418d0:	71 f4       	brne	.+28     	; 0x418ee <nvm_flash_erase_and_write_buffer+0x110>
					// The LSB of flash word must be changed
					// because the user buffer is not empty
					len--;
   418d2:	b1 e0       	ldi	r27, 0x01	; 1
   418d4:	eb 1a       	sub	r14, r27
   418d6:	f1 08       	sbc	r15, r1
   418d8:	63 01       	movw	r12, r6
   418da:	52 01       	movw	r10, r4
   418dc:	e2 e0       	ldi	r30, 0x02	; 2
   418de:	ae 0e       	add	r10, r30
   418e0:	b1 1c       	adc	r11, r1
   418e2:	c1 1c       	adc	r12, r1
   418e4:	d1 1c       	adc	r13, r1
					opt_address++;
					MSB(w_value)=*(uint8_t*)buf;
   418e6:	d1 01       	movw	r26, r2
   418e8:	8d 91       	ld	r24, X+
   418ea:	1d 01       	movw	r2, r26
   418ec:	8a 83       	std	Y+2, r24	; 0x02
					buf=(uint8_t*)buf+1;
				}
			}
			// Load flash buffer
			nvm_flash_load_word_to_buffer(page_address,w_value);
   418ee:	49 81       	ldd	r20, Y+1	; 0x01
   418f0:	5a 81       	ldd	r21, Y+2	; 0x02
   418f2:	c3 01       	movw	r24, r6
   418f4:	b2 01       	movw	r22, r4
   418f6:	1e 94 2f 01 	call	0x4025e	; 0x4025e <nvm_flash_load_word_to_buffer>
			page_address+=2;
   418fa:	b2 e0       	ldi	r27, 0x02	; 2
   418fc:	4b 0e       	add	r4, r27
   418fe:	51 1c       	adc	r5, r1
   41900:	61 1c       	adc	r6, r1
   41902:	71 1c       	adc	r7, r1
	// For each page
	while ( len ) {
		b_flag_erase = false;

		nvm_wait_until_ready();
		for (page_pos=0; page_pos<FLASH_PAGE_SIZE; page_pos+=2 ) {
   41904:	8b 81       	ldd	r24, Y+3	; 0x03
   41906:	9c 81       	ldd	r25, Y+4	; 0x04
   41908:	ad 81       	ldd	r26, Y+5	; 0x05
   4190a:	be 81       	ldd	r27, Y+6	; 0x06
   4190c:	48 16       	cp	r4, r24
   4190e:	59 06       	cpc	r5, r25
   41910:	6a 06       	cpc	r6, r26
   41912:	7b 06       	cpc	r7, r27
   41914:	09 f0       	breq	.+2      	; 0x41918 <nvm_flash_erase_and_write_buffer+0x13a>
   41916:	ac cf       	rjmp	.-168    	; 0x41870 <nvm_flash_erase_and_write_buffer+0x92>
   41918:	ab 86       	std	Y+11, r10	; 0x0b
   4191a:	bc 86       	std	Y+12, r11	; 0x0c
   4191c:	cd 86       	std	Y+13, r12	; 0x0d
   4191e:	de 86       	std	Y+14, r13	; 0x0e
   41920:	57 01       	movw	r10, r14
   41922:	73 01       	movw	r14, r6
   41924:	62 01       	movw	r12, r4
   41926:	35 01       	movw	r6, r10
			nvm_flash_load_word_to_buffer(page_address,w_value);
			page_address+=2;
		}

		// Write flash buffer
		if (b_flag_erase) {
   41928:	11 23       	and	r17, r17
   4192a:	61 f0       	breq	.+24     	; 0x41944 <nvm_flash_erase_and_write_buffer+0x166>
			nvm_flash_atomic_write_app_page(page_address-FLASH_PAGE_SIZE);
   4192c:	6f 81       	ldd	r22, Y+7	; 0x07
   4192e:	78 85       	ldd	r23, Y+8	; 0x08
   41930:	89 85       	ldd	r24, Y+9	; 0x09
   41932:	9a 85       	ldd	r25, Y+10	; 0x0a
 */
static inline void nvm_wait_until_ready( void )
{
	do {
		// Block execution while waiting for the NVM to be ready
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
   41934:	20 91 cf 01 	lds	r18, 0x01CF
   41938:	22 23       	and	r18, r18
   4193a:	e4 f3       	brlt	.-8      	; 0x41934 <nvm_flash_erase_and_write_buffer+0x156>
 * \param page_addr Byte address to the page to delete
 */
static inline void nvm_flash_atomic_write_app_page(flash_addr_t page_addr)
{
	nvm_wait_until_ready();
	nvm_common_spm(page_addr, NVM_CMD_ERASE_WRITE_APP_PAGE_gc);
   4193c:	45 e2       	ldi	r20, 0x25	; 37
   4193e:	1e 94 20 01 	call	0x40240	; 0x40240 <nvm_common_spm>
   41942:	0b c0       	rjmp	.+22     	; 0x4195a <nvm_flash_erase_and_write_buffer+0x17c>
		}else{
			nvm_flash_split_write_app_page(page_address-FLASH_PAGE_SIZE);
   41944:	6f 81       	ldd	r22, Y+7	; 0x07
   41946:	78 85       	ldd	r23, Y+8	; 0x08
   41948:	89 85       	ldd	r24, Y+9	; 0x09
   4194a:	9a 85       	ldd	r25, Y+10	; 0x0a
 */
static inline void nvm_wait_until_ready( void )
{
	do {
		// Block execution while waiting for the NVM to be ready
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
   4194c:	20 91 cf 01 	lds	r18, 0x01CF
   41950:	22 23       	and	r18, r18
   41952:	e4 f3       	brlt	.-8      	; 0x4194c <nvm_flash_erase_and_write_buffer+0x16e>
 * \param page_addr Byte address to the page to delete
 */
static inline void nvm_flash_split_write_app_page(flash_addr_t page_addr)
{
	nvm_wait_until_ready();
	nvm_common_spm(page_addr, NVM_CMD_WRITE_APP_PAGE_gc);
   41954:	44 e2       	ldi	r20, 0x24	; 36
   41956:	1e 94 20 01 	call	0x40240	; 0x40240 <nvm_common_spm>

	// Compute the start of the page to be modified
	page_address = opt_address-(opt_address%FLASH_PAGE_SIZE);

	// For each page
	while ( len ) {
   4195a:	67 28       	or	r6, r7
   4195c:	29 f0       	breq	.+10     	; 0x41968 <nvm_flash_erase_and_write_buffer+0x18a>
   4195e:	cf 82       	std	Y+7, r12	; 0x07
   41960:	d8 86       	std	Y+8, r13	; 0x08
   41962:	e9 86       	std	Y+9, r14	; 0x09
   41964:	fa 86       	std	Y+10, r15	; 0x0a
   41966:	69 cf       	rjmp	.-302    	; 0x4183a <nvm_flash_erase_and_write_buffer+0x5c>
			nvm_flash_atomic_write_app_page(page_address-FLASH_PAGE_SIZE);
		}else{
			nvm_flash_split_write_app_page(page_address-FLASH_PAGE_SIZE);
		}
	}
}
   41968:	2e 96       	adiw	r28, 0x0e	; 14
   4196a:	cd bf       	out	0x3d, r28	; 61
   4196c:	de bf       	out	0x3e, r29	; 62
   4196e:	df 91       	pop	r29
   41970:	cf 91       	pop	r28
   41972:	1f 91       	pop	r17
   41974:	0f 91       	pop	r16
   41976:	ff 90       	pop	r15
   41978:	ef 90       	pop	r14
   4197a:	df 90       	pop	r13
   4197c:	cf 90       	pop	r12
   4197e:	bf 90       	pop	r11
   41980:	af 90       	pop	r10
   41982:	9f 90       	pop	r9
   41984:	8f 90       	pop	r8
   41986:	7f 90       	pop	r7
   41988:	6f 90       	pop	r6
   4198a:	5f 90       	pop	r5
   4198c:	4f 90       	pop	r4
   4198e:	3f 90       	pop	r3
   41990:	2f 90       	pop	r2
   41992:	08 95       	ret

00041994 <nvm_read_byte>:
#endif

#ifndef __DOXYGEN__
	PUBLIC_FUNCTION(nvm_read_byte)
#if defined(__GNUC__)
	lds r20, NVM_CMD          ; Store NVM command register
   41994:	40 91 ca 01 	lds	r20, 0x01CA
	mov ZL, r22               ; Load byte index into low byte of Z.
   41998:	e6 2f       	mov	r30, r22
	mov ZH, r23               ; Load high byte into Z.
   4199a:	f7 2f       	mov	r31, r23
	sts NVM_CMD, r24          ; Load prepared command into NVM Command register.
   4199c:	80 93 ca 01 	sts	0x01CA, r24
	lpm r24, Z                ; Perform an LPM to read out byte
   419a0:	84 91       	lpm	r24, Z
	sts NVM_CMD, r20          ; Restore NVM command register
   419a2:	40 93 ca 01 	sts	0x01CA, r20
	sts NVM_CMD, r16          ; Load prepared command into NVM Command register.
	lpm r16, Z                ; Perform an LPM to read out byte
	sts NVM_CMD, r20          ; Restore NVM command register
#endif

	ret
   419a6:	08 95       	ret

000419a8 <ccp_write_io>:

	PUBLIC_FUNCTION(ccp_write_io)

#if defined(__GNUC__)

	out     RAMPZ, r1               // Reset bits 23:16 of Z
   419a8:	1b be       	out	0x3b, r1	; 59
	movw    r30, r24                // Load addr into Z
   419aa:	fc 01       	movw	r30, r24
	ldi     r18, CCP_IOREG          // Load magic CCP value
   419ac:	28 ed       	ldi	r18, 0xD8	; 216
	out     CCP, r18                // Start CCP handshake
   419ae:	24 bf       	out	0x34, r18	; 52
	st      Z, r22                  // Write value to I/O register
   419b0:	60 83       	st	Z, r22
	ret                             // Return to caller
   419b2:	08 95       	ret

000419b4 <main>:
void isp_start_appli(void);

extern uint16_t start_app_key;

int main (void)
{
   419b4:	cf 93       	push	r28
   419b6:	df 93       	push	r29
    // PORTS CONFIGURATION
    PORTA.DIR       = 0b00101110;   // 1.024V, BATTSENSE, x, CH1, x, x, x, 2.048V
   419b8:	e0 e0       	ldi	r30, 0x00	; 0
   419ba:	f6 e0       	ldi	r31, 0x06	; 6
   419bc:	8e e2       	ldi	r24, 0x2E	; 46
   419be:	80 83       	st	Z, r24
    PORTA.PIN4CTRL  = 0x07;         // Input Disable on pin PA4
   419c0:	87 e0       	ldi	r24, 0x07	; 7
   419c2:	84 8b       	std	Z+20, r24	; 0x14
    PORTA.PIN6CTRL  = 0x07;         // Input Disable on pin PA6
   419c4:	86 8b       	std	Z+22, r24	; 0x16
    PORTA.PIN7CTRL  = 0x07;         // Input Disable on pin PA7
   419c6:	87 8b       	std	Z+23, r24	; 0x17
    PORTB.DIR       = 0b11000011;   // LOGICDIR, ANPOW, CH2, 1.024V, AWG, TRIG, x, x
   419c8:	e0 e2       	ldi	r30, 0x20	; 32
   419ca:	f6 e0       	ldi	r31, 0x06	; 6
   419cc:	93 ec       	ldi	r25, 0xC3	; 195
   419ce:	90 83       	st	Z, r25
    PORTB.PIN2CTRL  = 0x01;         // Sense rising edge (Freq. counter)
   419d0:	91 e0       	ldi	r25, 0x01	; 1
   419d2:	92 8b       	std	Z+18, r25	; 0x12
    PORTB.PIN3CTRL	= 0x07;         // Input Disable on pin PB3
   419d4:	83 8b       	std	Z+19, r24	; 0x13
    PORTB.PIN4CTRL  = 0x07;         // Input Disable on pin PB4
   419d6:	84 8b       	std	Z+20, r24	; 0x14
    PORTB.PIN5CTRL  = 0x07;         // Input Disable on pin PB5
   419d8:	85 8b       	std	Z+21, r24	; 0x15
    PORTB.OUT       = 0b10000000;   // Logic port as input, Analog power off
   419da:	80 e8       	ldi	r24, 0x80	; 128
   419dc:	84 83       	std	Z+4, r24	; 0x04
    //PORTC.DIR = 0b00000000;       // LOGIC, register initial value is 0
    PORTD.DIR       = 0b00111111;   // D+, D-, LCDVDD, EXTCOMM, LCDIN, LCDDISP, LCDCLK, LCDCS
   419de:	e0 e6       	ldi	r30, 0x60	; 96
   419e0:	f6 e0       	ldi	r31, 0x06	; 6
   419e2:	8f e3       	ldi	r24, 0x3F	; 63
   419e4:	80 83       	st	Z, r24
    PORTD.OUT       = 0b00100000;   // Power to LCD
   419e6:	90 e2       	ldi	r25, 0x20	; 32
   419e8:	94 83       	std	Z+4, r25	; 0x04
    PORTE.DIR       = 0b00111111;   // Crystal, crystal, buzzer, buzzer, BATTSENSEPOW, RED, GRN, WHT
   419ea:	80 93 80 06 	sts	0x0680, r24
    // PORTE.OUT       = 0x20;
    // PORTF.DIR       = 0x00;      // Switches
    PORTCFG.MPCMASK = 0xFF;
   419ee:	a0 eb       	ldi	r26, 0xB0	; 176
   419f0:	b0 e0       	ldi	r27, 0x00	; 0
   419f2:	8f ef       	ldi	r24, 0xFF	; 255
   419f4:	8c 93       	st	X, r24
    PORTF.PIN0CTRL  = 0x18;         // Pull up on pin Port F
   419f6:	e0 ea       	ldi	r30, 0xA0	; 160
   419f8:	f6 e0       	ldi	r31, 0x06	; 6
   419fa:	88 e1       	ldi	r24, 0x18	; 24
   419fc:	80 8b       	std	Z+16, r24	; 0x10
    PORTF.INTCTRL   = 0x02;         // PORTA will generate medium level interrupts
   419fe:	82 e0       	ldi	r24, 0x02	; 2
   41a00:	81 87       	std	Z+9, r24	; 0x09
    PORTCFG.VPCTRLA = 0x41;         // VP1 Map to PORTE, VP0 Map to PORTB
   41a02:	81 e4       	ldi	r24, 0x41	; 65
   41a04:	12 96       	adiw	r26, 0x02	; 2
   41a06:	8c 93       	st	X, r24
   41a08:	12 97       	sbiw	r26, 0x02	; 2
    PORTCFG.VPCTRLB = 0x32;         // VP3 Map to PORTD, VP2 Map to PORTC
   41a0a:	82 e3       	ldi	r24, 0x32	; 50
   41a0c:	13 96       	adiw	r26, 0x03	; 3
   41a0e:	8c 93       	st	X, r24

	if (!(PORTF.IN & (1<<7))		// If the specified pin is pulled LOW
   41a10:	80 85       	ldd	r24, Z+8	; 0x08
   41a12:	88 23       	and	r24, r24
   41a14:	94 f4       	brge	.+36     	; 0x41a3a <main+0x86>
	|| pgm_read_word(0) == 0xFFFF	// Get the value of the reset vector. If it's unprogrammed, we know
   41a16:	e0 e0       	ldi	r30, 0x00	; 0
   41a18:	f0 e0       	ldi	r31, 0x00	; 0
   41a1a:	85 91       	lpm	r24, Z+
   41a1c:	94 91       	lpm	r25, Z
   41a1e:	01 96       	adiw	r24, 0x01	; 1
   41a20:	61 f0       	breq	.+24     	; 0x41a3a <main+0x86>
	// there's nothing useful in app flash
	|| (RST.STATUS & RST_SRF_bm && start_app_key!=0x55AA) // If the app code reset into the bootloader
   41a22:	80 91 78 00 	lds	r24, 0x0078
   41a26:	85 ff       	sbrs	r24, 5
   41a28:	3c c0       	rjmp	.+120    	; 0x41aa2 <main+0xee>
   41a2a:	80 91 73 29 	lds	r24, 0x2973
   41a2e:	90 91 74 29 	lds	r25, 0x2974
   41a32:	8a 3a       	cpi	r24, 0xAA	; 170
   41a34:	95 45       	sbci	r25, 0x55	; 85
   41a36:	09 f4       	brne	.+2      	; 0x41a3a <main+0x86>
   41a38:	3b c0       	rjmp	.+118    	; 0x41ab0 <main+0xfc>
	) {	
		// Map interrupt vectors table in bootloader section
		ccp_write_io((uint8_t*)&PMIC.CTRL, PMIC_IVSEL_bm | PMIC_LOLVLEN_bm
   41a3a:	67 e4       	ldi	r22, 0x47	; 71
   41a3c:	82 ea       	ldi	r24, 0xA2	; 162
   41a3e:	90 e0       	ldi	r25, 0x00	; 0
   41a40:	b3 df       	rcall	.-154    	; 0x419a8 <ccp_write_io>
				| PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm);
		sysclk_init();
   41a42:	fe dc       	rcall	.-1540   	; 0x41440 <sysclk_init>
		cpu_irq_enable();
   41a44:	78 94       	sei
		VPORT1.OUT = 0b00100000;
   41a46:	80 e2       	ldi	r24, 0x20	; 32
   41a48:	85 bb       	out	0x15, r24	; 21
		for(uint16_t t=10; t<1000; t+=4) {	// Intro Sound
   41a4a:	2a e0       	ldi	r18, 0x0A	; 10
   41a4c:	30 e0       	ldi	r19, 0x00	; 0
   41a4e:	8a e0       	ldi	r24, 0x0A	; 10
   41a50:	90 e0       	ldi	r25, 0x00	; 0
			for(uint16_t n=t; n<1010; n++) { _delay_us(100); }
			VPORT1.OUT ^= 0b00110000;
   41a52:	40 e3       	ldi	r20, 0x30	; 48
   41a54:	13 c0       	rjmp	.+38     	; 0x41a7c <main+0xc8>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
   41a56:	e1 e2       	ldi	r30, 0x21	; 33
   41a58:	ea 95       	dec	r30
   41a5a:	f1 f7       	brne	.-4      	; 0x41a58 <main+0xa4>
   41a5c:	00 00       	nop
				| PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm);
		sysclk_init();
		cpu_irq_enable();
		VPORT1.OUT = 0b00100000;
		for(uint16_t t=10; t<1000; t+=4) {	// Intro Sound
			for(uint16_t n=t; n<1010; n++) { _delay_us(100); }
   41a5e:	01 96       	adiw	r24, 0x01	; 1
   41a60:	82 3f       	cpi	r24, 0xF2	; 242
   41a62:	f3 e0       	ldi	r31, 0x03	; 3
   41a64:	9f 07       	cpc	r25, r31
   41a66:	b9 f7       	brne	.-18     	; 0x41a56 <main+0xa2>
			VPORT1.OUT ^= 0b00110000;
   41a68:	85 b3       	in	r24, 0x15	; 21
   41a6a:	84 27       	eor	r24, r20
   41a6c:	85 bb       	out	0x15, r24	; 21
		ccp_write_io((uint8_t*)&PMIC.CTRL, PMIC_IVSEL_bm | PMIC_LOLVLEN_bm
				| PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm);
		sysclk_init();
		cpu_irq_enable();
		VPORT1.OUT = 0b00100000;
		for(uint16_t t=10; t<1000; t+=4) {	// Intro Sound
   41a6e:	c9 01       	movw	r24, r18
   41a70:	04 96       	adiw	r24, 0x04	; 4
   41a72:	8a 3e       	cpi	r24, 0xEA	; 234
   41a74:	23 e0       	ldi	r18, 0x03	; 3
   41a76:	92 07       	cpc	r25, r18
   41a78:	31 f0       	breq	.+12     	; 0x41a86 <main+0xd2>
   41a7a:	9c 01       	movw	r18, r24
			for(uint16_t n=t; n<1010; n++) { _delay_us(100); }
   41a7c:	82 3f       	cpi	r24, 0xF2	; 242
   41a7e:	53 e0       	ldi	r21, 0x03	; 3
   41a80:	95 07       	cpc	r25, r21
   41a82:	48 f3       	brcs	.-46     	; 0x41a56 <main+0xa2>
   41a84:	f1 cf       	rjmp	.-30     	; 0x41a68 <main+0xb4>
			VPORT1.OUT ^= 0b00110000;
		}

		udc_start();
   41a86:	1e 94 ee 03 	call	0x407dc	; 0x407dc <udc_start>
 * then it will attach device when an acceptable Vbus
 * level from the host is detected.
 */
static inline void udc_attach(void)
{
	udd_attach();
   41a8a:	9c da       	rcall	.-2760   	; 0x40fc4 <udd_attach>
		udc_attach();
		while (true) {	
			VPORT1.OUT = 0;
			if( (!(PORTF.IN & (1<<4))) && (!(PORTF.IN & (1<<4))) ) isp_start_appli();
   41a8c:	c0 ea       	ldi	r28, 0xA0	; 160
   41a8e:	d6 e0       	ldi	r29, 0x06	; 6
		}

		udc_start();
		udc_attach();
		while (true) {	
			VPORT1.OUT = 0;
   41a90:	15 ba       	out	0x15, r1	; 21
			if( (!(PORTF.IN & (1<<4))) && (!(PORTF.IN & (1<<4))) ) isp_start_appli();
   41a92:	88 85       	ldd	r24, Y+8	; 0x08
   41a94:	84 fd       	sbrc	r24, 4
   41a96:	fc cf       	rjmp	.-8      	; 0x41a90 <main+0xdc>
   41a98:	88 85       	ldd	r24, Y+8	; 0x08
   41a9a:	84 fd       	sbrc	r24, 4
   41a9c:	f9 cf       	rjmp	.-14     	; 0x41a90 <main+0xdc>
   41a9e:	c0 dc       	rcall	.-1664   	; 0x41420 <isp_start_appli>
   41aa0:	f7 cf       	rjmp	.-18     	; 0x41a90 <main+0xdc>
		}
	}

	if(start_app_key==0x55AA) {
   41aa2:	80 91 73 29 	lds	r24, 0x2973
   41aa6:	90 91 74 29 	lds	r25, 0x2974
   41aaa:	8a 3a       	cpi	r24, 0xAA	; 170
   41aac:	95 45       	sbci	r25, 0x55	; 85
   41aae:	39 f4       	brne	.+14     	; 0x41abe <main+0x10a>
		RST.STATUS = RST_SRF_bm;
   41ab0:	80 e2       	ldi	r24, 0x20	; 32
   41ab2:	80 93 78 00 	sts	0x0078, r24
		start_app_key = 0;		
   41ab6:	10 92 73 29 	sts	0x2973, r1
   41aba:	10 92 74 29 	sts	0x2974, r1
	}
	EIND = 0x00;
   41abe:	1c be       	out	0x3c, r1	; 60
	void (*reset_vect)( void ) = 0x000000;
	reset_vect();
   41ac0:	e0 e0       	ldi	r30, 0x00	; 0
   41ac2:	f0 e0       	ldi	r31, 0x00	; 0
   41ac4:	19 95       	eicall
}
   41ac6:	80 e0       	ldi	r24, 0x00	; 0
   41ac8:	90 e0       	ldi	r25, 0x00	; 0
   41aca:	df 91       	pop	r29
   41acc:	cf 91       	pop	r28
   41ace:	08 95       	ret

00041ad0 <memcpy>:
   41ad0:	fb 01       	movw	r30, r22
   41ad2:	dc 01       	movw	r26, r24
   41ad4:	02 c0       	rjmp	.+4      	; 0x41ada <memcpy+0xa>
   41ad6:	01 90       	ld	r0, Z+
   41ad8:	0d 92       	st	X+, r0
   41ada:	41 50       	subi	r20, 0x01	; 1
   41adc:	50 40       	sbci	r21, 0x00	; 0
   41ade:	d8 f7       	brcc	.-10     	; 0x41ad6 <memcpy+0x6>
   41ae0:	08 95       	ret

00041ae2 <_exit>:
   41ae2:	f8 94       	cli

00041ae4 <__stop_program>:
   41ae4:	ff cf       	rjmp	.-2      	; 0x41ae4 <__stop_program>
